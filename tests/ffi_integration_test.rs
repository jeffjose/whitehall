use std::fs;
use std::path::Path;
use tempfile::TempDir;

use whitehall::ffi_parser::cpp::discover_cpp_ffi;
use whitehall::ffi_codegen::{generate_kotlin_object, generate_jni_bridge, generate_cmake};

#[test]
fn test_ffi_end_to_end() {
    // Create a temporary directory with test C++ file
    let temp_dir = TempDir::new().unwrap();
    let ffi_dir = temp_dir.path().join("ffi");
    let cpp_dir = ffi_dir.join("cpp");
    fs::create_dir_all(&cpp_dir).unwrap();

    // Write test C++ file
    let cpp_content = r#"
// @ffi
int add(int a, int b) {
    return a + b;
}

// @ffi
int multiply(int x, int y) {
    return x * y;
}

// @ffi
bool isPositive(int n) {
    return n > 0;
}

// Helper (not FFI)
int helper(int x) {
    return x * 2;
}
"#;
    fs::write(cpp_dir.join("math.cpp"), cpp_content).unwrap();

    // Test 1: Discover FFI functions
    let functions = discover_cpp_ffi(&ffi_dir).unwrap();
    assert_eq!(functions.len(), 3, "Should find 3 @ffi functions");

    let function_names: Vec<_> = functions.iter().map(|f| f.name.as_str()).collect();
    assert!(function_names.contains(&"add"));
    assert!(function_names.contains(&"multiply"));
    assert!(function_names.contains(&"isPositive"));
    assert!(!function_names.contains(&"helper"), "helper should not be discovered");

    // Test 2: Generate Kotlin bindings
    let kotlin_code = generate_kotlin_object(
        &functions,
        "com.example.test",
        "math",
        "Math",
    );

    assert!(kotlin_code.contains("package com.example.test"));
    assert!(kotlin_code.contains("object Math"));
    assert!(kotlin_code.contains("external fun add(a: Int, b: Int): Int"));
    assert!(kotlin_code.contains("external fun multiply(x: Int, y: Int): Int"));
    assert!(kotlin_code.contains("external fun isPositive(n: Int): Boolean"));
    assert!(kotlin_code.contains("System.loadLibrary(\"math\")"));
    assert!(kotlin_code.contains("Auto-generated by Whitehall FFI"));

    // Test 3: Generate JNI bridge
    let jni_code = generate_jni_bridge(
        &functions,
        "com.example.test",
        &["ffi/cpp/math.cpp".to_string()],
    );

    assert!(jni_code.contains("#include <jni.h>"));
    assert!(jni_code.contains("#include \"ffi/cpp/math.cpp\""));
    assert!(jni_code.contains("Java_com_example_test_Math_add"));
    assert!(jni_code.contains("Java_com_example_test_Math_multiply"));
    assert!(jni_code.contains("Java_com_example_test_Math_isPositive"));
    assert!(jni_code.contains("jint"));
    assert!(jni_code.contains("jboolean"));
    assert!(jni_code.contains("return add(a, b)"));
    assert!(jni_code.contains("return multiply(x, y)"));
    assert!(jni_code.contains("return isPositive(n)"));

    // Test 4: Generate CMake
    let cmake_code = generate_cmake(
        "math",
        &["ffi/cpp/math.cpp".to_string()],
        "build/jni/math_bridge.cpp",
        "17",
        &[],
        &[],
    );

    assert!(cmake_code.contains("cmake_minimum_required(VERSION 3.22.1)"));
    assert!(cmake_code.contains("project(\"math\")"));
    assert!(cmake_code.contains("add_library(math SHARED"));
    assert!(cmake_code.contains("ffi/cpp/math.cpp"));
    assert!(cmake_code.contains("build/jni/math_bridge.cpp"));
    assert!(cmake_code.contains("CMAKE_CXX_STANDARD 17"));
    assert!(cmake_code.contains("find_library(log-lib log)"));
}

#[test]
fn test_ffi_parser_primitives_only() {
    let temp_dir = TempDir::new().unwrap();
    let ffi_dir = temp_dir.path().join("ffi");
    let cpp_dir = ffi_dir.join("cpp");
    fs::create_dir_all(&cpp_dir).unwrap();

    // Test all supported primitive types
    let cpp_content = r#"
// @ffi
int testInt(int x) { return x; }

// @ffi
long long testLong(long long x) { return x; }

// @ffi
float testFloat(float x) { return x; }

// @ffi
double testDouble(double x) { return x; }

// @ffi
bool testBool(bool x) { return x; }

// @ffi
void testVoid(int x) { }
"#;
    fs::write(cpp_dir.join("types.cpp"), cpp_content).unwrap();

    let functions = discover_cpp_ffi(&ffi_dir).unwrap();
    assert_eq!(functions.len(), 6);

    // Verify Kotlin type mapping
    let kotlin_code = generate_kotlin_object(&functions, "com.test", "test", "Test");
    assert!(kotlin_code.contains("x: Int"));
    assert!(kotlin_code.contains("x: Long"));
    assert!(kotlin_code.contains("x: Float"));
    assert!(kotlin_code.contains("x: Double"));
    assert!(kotlin_code.contains("x: Boolean"));
    assert!(kotlin_code.contains("fun testVoid(x: Int)\n")); // No return type for void
}

#[test]
fn test_ffi_parser_string_support() {
    let temp_dir = TempDir::new().unwrap();
    let ffi_dir = temp_dir.path().join("ffi");
    let cpp_dir = ffi_dir.join("cpp");
    fs::create_dir_all(&cpp_dir).unwrap();

    // Phase 2: std::string is now supported
    let cpp_content = r#"
// @ffi
std::string greet(std::string name) {
    return "Hello, " + name;
}
"#;
    fs::write(cpp_dir.join("string.cpp"), cpp_content).unwrap();

    let result = discover_cpp_ffi(&ffi_dir);
    assert!(result.is_ok(), "Phase 2 should support std::string");

    let functions = result.unwrap();
    assert_eq!(functions.len(), 1);
    assert_eq!(functions[0].name, "greet");
    assert_eq!(functions[0].return_type, whitehall::ffi_parser::CppType::String);
    assert_eq!(functions[0].params[0].1, whitehall::ffi_parser::CppType::String);
}

#[test]
fn test_ffi_string_end_to_end() {
    // Create a temporary directory with test C++ file
    let temp_dir = TempDir::new().unwrap();
    let ffi_dir = temp_dir.path().join("ffi");
    let cpp_dir = ffi_dir.join("cpp");
    fs::create_dir_all(&cpp_dir).unwrap();

    // Write test C++ file with string functions
    let cpp_content = r#"
// @ffi
std::string greet(std::string name) {
    return "Hello, " + name + "!";
}

// @ffi
std::string toUpper(std::string text) {
    std::string result = text;
    for (char& c : result) {
        c = toupper(c);
    }
    return result;
}

// @ffi
std::string formatNumber(std::string format, int number) {
    return format + std::to_string(number);
}
"#;
    fs::write(cpp_dir.join("strings.cpp"), cpp_content).unwrap();

    // Test 1: Discover FFI functions
    let functions = discover_cpp_ffi(&ffi_dir).unwrap();
    assert_eq!(functions.len(), 3, "Should find 3 @ffi functions");

    // Test 2: Generate Kotlin bindings
    let kotlin_code = generate_kotlin_object(
        &functions,
        "com.example.test",
        "strings",
        "Strings",
    );

    assert!(kotlin_code.contains("package com.example.test"));
    assert!(kotlin_code.contains("object Strings"));
    assert!(kotlin_code.contains("external fun greet(name: String): String"));
    assert!(kotlin_code.contains("external fun toUpper(text: String): String"));
    assert!(kotlin_code.contains("external fun formatNumber(format: String, number: Int): String"));
    assert!(kotlin_code.contains("System.loadLibrary(\"strings\")"));

    // Test 3: Generate JNI bridge with string conversions
    let jni_code = generate_jni_bridge(
        &functions,
        "com.example.test",
        &["ffi/cpp/strings.cpp".to_string()],
    );

    // Check forward declarations
    assert!(jni_code.contains("std::string greet(const std::string&);"));
    assert!(jni_code.contains("std::string toUpper(const std::string&);"));
    assert!(jni_code.contains("std::string formatNumber(const std::string&, int);"));

    // Check string conversions
    assert!(jni_code.contains("GetStringUTFChars"));
    assert!(jni_code.contains("ReleaseStringUTFChars"));
    assert!(jni_code.contains("NewStringUTF"));

    // Check JNI function signatures
    assert!(jni_code.contains("jstring JNICALL"));
    assert!(jni_code.contains("jstring name"));
    assert!(jni_code.contains("jstring text"));
    assert!(jni_code.contains("jstring format"));

    // Check function calls with converted parameters
    assert!(jni_code.contains("cpp_name"));
    assert!(jni_code.contains("cpp_text"));
    assert!(jni_code.contains("cpp_format"));

    // Test 4: Generate CMake
    let cmake_code = generate_cmake(
        "strings",
        &["ffi/cpp/strings.cpp".to_string()],
        "build/jni/strings_bridge.cpp",
        "17",
        &[],
        &[],
    );

    assert!(cmake_code.contains("project(\"strings\")"));
    assert!(cmake_code.contains("ffi/cpp/strings.cpp"));
    assert!(cmake_code.contains("build/jni/strings_bridge.cpp"));
}

#[test]
fn test_ffi_array_end_to_end() {
    // Create a temporary directory with test C++ file
    let temp_dir = TempDir::new().unwrap();
    let ffi_dir = temp_dir.path().join("ffi");
    let cpp_dir = ffi_dir.join("cpp");
    fs::create_dir_all(&cpp_dir).unwrap();

    // Write test C++ file with array functions
    // NOTE: Put opening brace on same line for regex matching
    let cpp_content = r#"
// @ffi
std::vector<int> doubleValues(std::vector<int> values) {
    return values;
}

// @ffi
int sumArray(const std::vector<int>& values) {
    return 0;
}

// @ffi
std::vector<std::string> toUpperCase(std::vector<std::string> strings) {
    return strings;
}
"#;
    fs::write(cpp_dir.join("arrays.cpp"), cpp_content).unwrap();

    // Test 1: Discover FFI functions
    let functions = discover_cpp_ffi(&ffi_dir).unwrap();
    assert_eq!(functions.len(), 3, "Should find 3 @ffi functions");

    // Test 2: Check types are correct
    assert_eq!(functions[0].name, "doubleValues");
    assert_eq!(functions[0].params[0].1, whitehall::ffi_parser::CppType::IntArray);
    assert_eq!(functions[0].return_type, whitehall::ffi_parser::CppType::IntArray);

    assert_eq!(functions[1].name, "sumArray");
    assert_eq!(functions[1].params[0].1, whitehall::ffi_parser::CppType::IntArray);
    assert_eq!(functions[1].return_type, whitehall::ffi_parser::CppType::Int);

    assert_eq!(functions[2].name, "toUpperCase");
    assert_eq!(functions[2].params[0].1, whitehall::ffi_parser::CppType::StringArray);
    assert_eq!(functions[2].return_type, whitehall::ffi_parser::CppType::StringArray);

    // Test 3: Generate Kotlin bindings
    let kotlin_code = generate_kotlin_object(
        &functions,
        "com.example.test",
        "arrays",
        "Arrays",
    );

    assert!(kotlin_code.contains("package com.example.test"));
    assert!(kotlin_code.contains("object Arrays"));
    assert!(kotlin_code.contains("external fun doubleValues(values: IntArray): IntArray"));
    assert!(kotlin_code.contains("external fun sumArray(values: IntArray): Int"));
    assert!(kotlin_code.contains("external fun toUpperCase(strings: Array<String>): Array<String>"));
    assert!(kotlin_code.contains("System.loadLibrary(\"arrays\")"));

    // Test 4: Generate JNI bridge with array conversions
    let jni_code = generate_jni_bridge(
        &functions,
        "com.example.test",
        &["ffi/cpp/arrays.cpp".to_string()],
    );

    println!("{}", jni_code);

    // Check forward declarations use const reference for arrays
    assert!(jni_code.contains("std::vector<int> doubleValues(const std::vector<int>&);"));
    assert!(jni_code.contains("int sumArray(const std::vector<int>&);"));
    assert!(jni_code.contains("std::vector<std::string> toUpperCase(const std::vector<std::string>&);"));

    // Check JNI function signatures
    assert!(jni_code.contains("jintArray JNICALL"));
    assert!(jni_code.contains("jintArray values"));

    // Check array conversions
    assert!(jni_code.contains("GetArrayLength"));
    assert!(jni_code.contains("GetIntArrayElements"));
    assert!(jni_code.contains("ReleaseIntArrayElements"));
    assert!(jni_code.contains("NewIntArray"));
    assert!(jni_code.contains("SetIntArrayRegion"));

    // Check string array conversions
    assert!(jni_code.contains("GetObjectArrayElement"));
    assert!(jni_code.contains("NewObjectArray"));
    assert!(jni_code.contains("SetObjectArrayElement"));

    // Check vector construction
    assert!(jni_code.contains("std::vector<int> cpp_values"));
    assert!(jni_code.contains("std::vector<std::string> cpp_strings"));

    // Test 5: Generate CMake
    let cmake_code = generate_cmake(
        "arrays",
        &["ffi/cpp/arrays.cpp".to_string()],
        "build/jni/arrays_bridge.cpp",
        "17",
        &[],
        &[],
    );

    assert!(cmake_code.contains("project(\"arrays\")"));
    assert!(cmake_code.contains("ffi/cpp/arrays.cpp"));
    assert!(cmake_code.contains("build/jni/arrays_bridge.cpp"));
}
