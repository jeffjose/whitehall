use std::fs;
use std::path::Path;
use tempfile::TempDir;

use whitehall::ffi_parser::cpp::discover_cpp_ffi;
use whitehall::ffi_codegen::{generate_kotlin_object, generate_jni_bridge, generate_cmake};

#[test]
fn test_ffi_end_to_end() {
    // Create a temporary directory with test C++ file
    let temp_dir = TempDir::new().unwrap();
    let ffi_dir = temp_dir.path().join("ffi");
    let cpp_dir = ffi_dir.join("cpp");
    fs::create_dir_all(&cpp_dir).unwrap();

    // Write test C++ file
    let cpp_content = r#"
// @ffi
int add(int a, int b) {
    return a + b;
}

// @ffi
int multiply(int x, int y) {
    return x * y;
}

// @ffi
bool isPositive(int n) {
    return n > 0;
}

// Helper (not FFI)
int helper(int x) {
    return x * 2;
}
"#;
    fs::write(cpp_dir.join("math.cpp"), cpp_content).unwrap();

    // Test 1: Discover FFI functions
    let functions = discover_cpp_ffi(&ffi_dir).unwrap();
    assert_eq!(functions.len(), 3, "Should find 3 @ffi functions");

    let function_names: Vec<_> = functions.iter().map(|f| f.name.as_str()).collect();
    assert!(function_names.contains(&"add"));
    assert!(function_names.contains(&"multiply"));
    assert!(function_names.contains(&"isPositive"));
    assert!(!function_names.contains(&"helper"), "helper should not be discovered");

    // Test 2: Generate Kotlin bindings
    let kotlin_code = generate_kotlin_object(
        &functions,
        "com.example.test",
        "math",
        "Math",
    );

    assert!(kotlin_code.contains("package com.example.test"));
    assert!(kotlin_code.contains("object Math"));
    assert!(kotlin_code.contains("external fun add(a: Int, b: Int): Int"));
    assert!(kotlin_code.contains("external fun multiply(x: Int, y: Int): Int"));
    assert!(kotlin_code.contains("external fun isPositive(n: Int): Boolean"));
    assert!(kotlin_code.contains("System.loadLibrary(\"math\")"));
    assert!(kotlin_code.contains("Auto-generated by Whitehall FFI"));

    // Test 3: Generate JNI bridge
    let jni_code = generate_jni_bridge(
        &functions,
        "com.example.test",
        &["ffi/cpp/math.cpp".to_string()],
    );

    assert!(jni_code.contains("#include <jni.h>"));
    assert!(jni_code.contains("#include \"ffi/cpp/math.cpp\""));
    assert!(jni_code.contains("Java_com_example_test_Math_add"));
    assert!(jni_code.contains("Java_com_example_test_Math_multiply"));
    assert!(jni_code.contains("Java_com_example_test_Math_isPositive"));
    assert!(jni_code.contains("jint"));
    assert!(jni_code.contains("jboolean"));
    assert!(jni_code.contains("return add(a, b)"));
    assert!(jni_code.contains("return multiply(x, y)"));
    assert!(jni_code.contains("return isPositive(n)"));

    // Test 4: Generate CMake
    let cmake_code = generate_cmake(
        "math",
        &["ffi/cpp/math.cpp".to_string()],
        "build/jni/math_bridge.cpp",
        "17",
        &[],
        &[],
    );

    assert!(cmake_code.contains("cmake_minimum_required(VERSION 3.22.1)"));
    assert!(cmake_code.contains("project(\"math\")"));
    assert!(cmake_code.contains("add_library(math SHARED"));
    assert!(cmake_code.contains("ffi/cpp/math.cpp"));
    assert!(cmake_code.contains("build/jni/math_bridge.cpp"));
    assert!(cmake_code.contains("CMAKE_CXX_STANDARD 17"));
    assert!(cmake_code.contains("find_library(log-lib log)"));
}

#[test]
fn test_ffi_parser_primitives_only() {
    let temp_dir = TempDir::new().unwrap();
    let ffi_dir = temp_dir.path().join("ffi");
    let cpp_dir = ffi_dir.join("cpp");
    fs::create_dir_all(&cpp_dir).unwrap();

    // Test all supported primitive types
    let cpp_content = r#"
// @ffi
int testInt(int x) { return x; }

// @ffi
long long testLong(long long x) { return x; }

// @ffi
float testFloat(float x) { return x; }

// @ffi
double testDouble(double x) { return x; }

// @ffi
bool testBool(bool x) { return x; }

// @ffi
void testVoid(int x) { }
"#;
    fs::write(cpp_dir.join("types.cpp"), cpp_content).unwrap();

    let functions = discover_cpp_ffi(&ffi_dir).unwrap();
    assert_eq!(functions.len(), 6);

    // Verify Kotlin type mapping
    let kotlin_code = generate_kotlin_object(&functions, "com.test", "test", "Test");
    assert!(kotlin_code.contains("x: Int"));
    assert!(kotlin_code.contains("x: Long"));
    assert!(kotlin_code.contains("x: Float"));
    assert!(kotlin_code.contains("x: Double"));
    assert!(kotlin_code.contains("x: Boolean"));
    assert!(kotlin_code.contains("fun testVoid(x: Int)\n")); // No return type for void
}

#[test]
fn test_ffi_parser_unsupported_types() {
    let temp_dir = TempDir::new().unwrap();
    let ffi_dir = temp_dir.path().join("ffi");
    let cpp_dir = ffi_dir.join("cpp");
    fs::create_dir_all(&cpp_dir).unwrap();

    // Test that unsupported types produce errors
    let cpp_content = r#"
// @ffi
std::string unsupported(std::string x) {
    return x;
}
"#;
    fs::write(cpp_dir.join("invalid.cpp"), cpp_content).unwrap();

    let result = discover_cpp_ffi(&ffi_dir);

    if result.is_err() {
        let error = result.unwrap_err();
        let error_msg = format!("{:?}", error);
        println!("Got expected error: {}", error_msg);
        // Check if the full error chain contains the message
        assert!(error_msg.contains("Unsupported C++ type") || error_msg.contains("std::string"),
                "Error chain should mention unsupported type or std::string, got: {}", error_msg);
    } else {
        let functions = result.unwrap();
        panic!("Expected error but got {} function(s). Phase 1 should reject std::string", functions.len());
    }
}
