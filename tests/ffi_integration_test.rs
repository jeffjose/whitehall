use std::fs;
use std::path::Path;
use tempfile::TempDir;

use whitehall::ffi_parser::cpp::discover_cpp_ffi;
use whitehall::ffi_parser::rust::discover_rust_ffi;
use whitehall::ffi_codegen::{
    generate_kotlin_object, generate_jni_bridge, generate_cmake,
    generate_kotlin_object_rust, generate_rust_bridge
};

#[test]
fn test_ffi_end_to_end() {
    // Create a temporary directory with test C++ file
    let temp_dir = TempDir::new().unwrap();
    let ffi_dir = temp_dir.path().join("ffi");
    let cpp_dir = ffi_dir.join("cpp");
    fs::create_dir_all(&cpp_dir).unwrap();

    // Write test C++ file
    let cpp_content = r#"
// @ffi
int add(int a, int b) {
    return a + b;
}

// @ffi
int multiply(int x, int y) {
    return x * y;
}

// @ffi
bool isPositive(int n) {
    return n > 0;
}

// Helper (not FFI)
int helper(int x) {
    return x * 2;
}
"#;
    fs::write(cpp_dir.join("math.cpp"), cpp_content).unwrap();

    // Test 1: Discover FFI functions
    let functions = discover_cpp_ffi(&ffi_dir).unwrap();
    assert_eq!(functions.len(), 3, "Should find 3 @ffi functions");

    let function_names: Vec<_> = functions.iter().map(|f| f.name.as_str()).collect();
    assert!(function_names.contains(&"add"));
    assert!(function_names.contains(&"multiply"));
    assert!(function_names.contains(&"isPositive"));
    assert!(!function_names.contains(&"helper"), "helper should not be discovered");

    // Test 2: Generate Kotlin bindings
    let kotlin_code = generate_kotlin_object(
        &functions,
        "com.example.test",
        "math",
        "Math",
    );

    assert!(kotlin_code.contains("package com.example.test"));
    assert!(kotlin_code.contains("object Math"));
    assert!(kotlin_code.contains("external fun add(a: Int, b: Int): Int"));
    assert!(kotlin_code.contains("external fun multiply(x: Int, y: Int): Int"));
    assert!(kotlin_code.contains("external fun isPositive(n: Int): Boolean"));
    assert!(kotlin_code.contains("System.loadLibrary(\"math\")"));
    assert!(kotlin_code.contains("Auto-generated by Whitehall FFI"));

    // Test 3: Generate JNI bridge
    let jni_code = generate_jni_bridge(
        &functions,
        "com.example.test",
        &["ffi/cpp/math.cpp".to_string()],
    );

    assert!(jni_code.contains("#include <jni.h>"));
    assert!(jni_code.contains("#include \"ffi/cpp/math.cpp\""));
    assert!(jni_code.contains("Java_com_example_test_Math_add"));
    assert!(jni_code.contains("Java_com_example_test_Math_multiply"));
    assert!(jni_code.contains("Java_com_example_test_Math_isPositive"));
    assert!(jni_code.contains("jint"));
    assert!(jni_code.contains("jboolean"));
    assert!(jni_code.contains("return add(a, b)"));
    assert!(jni_code.contains("return multiply(x, y)"));
    assert!(jni_code.contains("return isPositive(n)"));

    // Test 4: Generate CMake
    let cmake_code = generate_cmake(
        "math",
        &["ffi/cpp/math.cpp".to_string()],
        "build/jni/math_bridge.cpp",
        "17",
        &[],
        &[],
    );

    assert!(cmake_code.contains("cmake_minimum_required(VERSION 3.22.1)"));
    assert!(cmake_code.contains("project(\"math\")"));
    assert!(cmake_code.contains("add_library(math SHARED"));
    assert!(cmake_code.contains("ffi/cpp/math.cpp"));
    assert!(cmake_code.contains("build/jni/math_bridge.cpp"));
    assert!(cmake_code.contains("CMAKE_CXX_STANDARD 17"));
    assert!(cmake_code.contains("find_library(log-lib log)"));
}

#[test]
fn test_ffi_parser_primitives_only() {
    let temp_dir = TempDir::new().unwrap();
    let ffi_dir = temp_dir.path().join("ffi");
    let cpp_dir = ffi_dir.join("cpp");
    fs::create_dir_all(&cpp_dir).unwrap();

    // Test all supported primitive types
    let cpp_content = r#"
// @ffi
int testInt(int x) { return x; }

// @ffi
long long testLong(long long x) { return x; }

// @ffi
float testFloat(float x) { return x; }

// @ffi
double testDouble(double x) { return x; }

// @ffi
bool testBool(bool x) { return x; }

// @ffi
void testVoid(int x) { }
"#;
    fs::write(cpp_dir.join("types.cpp"), cpp_content).unwrap();

    let functions = discover_cpp_ffi(&ffi_dir).unwrap();
    assert_eq!(functions.len(), 6);

    // Verify Kotlin type mapping
    let kotlin_code = generate_kotlin_object(&functions, "com.test", "test", "Test");
    assert!(kotlin_code.contains("x: Int"));
    assert!(kotlin_code.contains("x: Long"));
    assert!(kotlin_code.contains("x: Float"));
    assert!(kotlin_code.contains("x: Double"));
    assert!(kotlin_code.contains("x: Boolean"));
    assert!(kotlin_code.contains("fun testVoid(x: Int)\n")); // No return type for void
}

#[test]
fn test_ffi_parser_string_support() {
    let temp_dir = TempDir::new().unwrap();
    let ffi_dir = temp_dir.path().join("ffi");
    let cpp_dir = ffi_dir.join("cpp");
    fs::create_dir_all(&cpp_dir).unwrap();

    // Phase 2: std::string is now supported
    let cpp_content = r#"
// @ffi
std::string greet(std::string name) {
    return "Hello, " + name;
}
"#;
    fs::write(cpp_dir.join("string.cpp"), cpp_content).unwrap();

    let result = discover_cpp_ffi(&ffi_dir);
    assert!(result.is_ok(), "Phase 2 should support std::string");

    let functions = result.unwrap();
    assert_eq!(functions.len(), 1);
    assert_eq!(functions[0].name, "greet");
    assert_eq!(functions[0].return_type, whitehall::ffi_parser::CppType::String);
    assert_eq!(functions[0].params[0].1, whitehall::ffi_parser::CppType::String);
}

#[test]
fn test_ffi_string_end_to_end() {
    // Create a temporary directory with test C++ file
    let temp_dir = TempDir::new().unwrap();
    let ffi_dir = temp_dir.path().join("ffi");
    let cpp_dir = ffi_dir.join("cpp");
    fs::create_dir_all(&cpp_dir).unwrap();

    // Write test C++ file with string functions
    let cpp_content = r#"
// @ffi
std::string greet(std::string name) {
    return "Hello, " + name + "!";
}

// @ffi
std::string toUpper(std::string text) {
    std::string result = text;
    for (char& c : result) {
        c = toupper(c);
    }
    return result;
}

// @ffi
std::string formatNumber(std::string format, int number) {
    return format + std::to_string(number);
}
"#;
    fs::write(cpp_dir.join("strings.cpp"), cpp_content).unwrap();

    // Test 1: Discover FFI functions
    let functions = discover_cpp_ffi(&ffi_dir).unwrap();
    assert_eq!(functions.len(), 3, "Should find 3 @ffi functions");

    // Test 2: Generate Kotlin bindings
    let kotlin_code = generate_kotlin_object(
        &functions,
        "com.example.test",
        "strings",
        "Strings",
    );

    assert!(kotlin_code.contains("package com.example.test"));
    assert!(kotlin_code.contains("object Strings"));
    assert!(kotlin_code.contains("external fun greet(name: String): String"));
    assert!(kotlin_code.contains("external fun toUpper(text: String): String"));
    assert!(kotlin_code.contains("external fun formatNumber(format: String, number: Int): String"));
    assert!(kotlin_code.contains("System.loadLibrary(\"strings\")"));

    // Test 3: Generate JNI bridge with string conversions
    let jni_code = generate_jni_bridge(
        &functions,
        "com.example.test",
        &["ffi/cpp/strings.cpp".to_string()],
    );

    // Check forward declarations
    assert!(jni_code.contains("std::string greet(const std::string&);"));
    assert!(jni_code.contains("std::string toUpper(const std::string&);"));
    assert!(jni_code.contains("std::string formatNumber(const std::string&, int);"));

    // Check string conversions
    assert!(jni_code.contains("GetStringUTFChars"));
    assert!(jni_code.contains("ReleaseStringUTFChars"));
    assert!(jni_code.contains("NewStringUTF"));

    // Check JNI function signatures
    assert!(jni_code.contains("jstring JNICALL"));
    assert!(jni_code.contains("jstring name"));
    assert!(jni_code.contains("jstring text"));
    assert!(jni_code.contains("jstring format"));

    // Check function calls with converted parameters
    assert!(jni_code.contains("cpp_name"));
    assert!(jni_code.contains("cpp_text"));
    assert!(jni_code.contains("cpp_format"));

    // Test 4: Generate CMake
    let cmake_code = generate_cmake(
        "strings",
        &["ffi/cpp/strings.cpp".to_string()],
        "build/jni/strings_bridge.cpp",
        "17",
        &[],
        &[],
    );

    assert!(cmake_code.contains("project(\"strings\")"));
    assert!(cmake_code.contains("ffi/cpp/strings.cpp"));
    assert!(cmake_code.contains("build/jni/strings_bridge.cpp"));
}

#[test]
fn test_ffi_array_end_to_end() {
    // Create a temporary directory with test C++ file
    let temp_dir = TempDir::new().unwrap();
    let ffi_dir = temp_dir.path().join("ffi");
    let cpp_dir = ffi_dir.join("cpp");
    fs::create_dir_all(&cpp_dir).unwrap();

    // Write test C++ file with array functions
    // NOTE: Put opening brace on same line for regex matching
    let cpp_content = r#"
// @ffi
std::vector<int> doubleValues(std::vector<int> values) {
    return values;
}

// @ffi
int sumArray(const std::vector<int>& values) {
    return 0;
}

// @ffi
std::vector<std::string> toUpperCase(std::vector<std::string> strings) {
    return strings;
}
"#;
    fs::write(cpp_dir.join("arrays.cpp"), cpp_content).unwrap();

    // Test 1: Discover FFI functions
    let functions = discover_cpp_ffi(&ffi_dir).unwrap();
    assert_eq!(functions.len(), 3, "Should find 3 @ffi functions");

    // Test 2: Check types are correct
    assert_eq!(functions[0].name, "doubleValues");
    assert_eq!(functions[0].params[0].1, whitehall::ffi_parser::CppType::IntArray);
    assert_eq!(functions[0].return_type, whitehall::ffi_parser::CppType::IntArray);

    assert_eq!(functions[1].name, "sumArray");
    assert_eq!(functions[1].params[0].1, whitehall::ffi_parser::CppType::IntArray);
    assert_eq!(functions[1].return_type, whitehall::ffi_parser::CppType::Int);

    assert_eq!(functions[2].name, "toUpperCase");
    assert_eq!(functions[2].params[0].1, whitehall::ffi_parser::CppType::StringArray);
    assert_eq!(functions[2].return_type, whitehall::ffi_parser::CppType::StringArray);

    // Test 3: Generate Kotlin bindings
    let kotlin_code = generate_kotlin_object(
        &functions,
        "com.example.test",
        "arrays",
        "Arrays",
    );

    assert!(kotlin_code.contains("package com.example.test"));
    assert!(kotlin_code.contains("object Arrays"));
    assert!(kotlin_code.contains("external fun doubleValues(values: IntArray): IntArray"));
    assert!(kotlin_code.contains("external fun sumArray(values: IntArray): Int"));
    assert!(kotlin_code.contains("external fun toUpperCase(strings: Array<String>): Array<String>"));
    assert!(kotlin_code.contains("System.loadLibrary(\"arrays\")"));

    // Test 4: Generate JNI bridge with array conversions
    let jni_code = generate_jni_bridge(
        &functions,
        "com.example.test",
        &["ffi/cpp/arrays.cpp".to_string()],
    );

    println!("{}", jni_code);

    // Check forward declarations use const reference for arrays
    assert!(jni_code.contains("std::vector<int> doubleValues(const std::vector<int>&);"));
    assert!(jni_code.contains("int sumArray(const std::vector<int>&);"));
    assert!(jni_code.contains("std::vector<std::string> toUpperCase(const std::vector<std::string>&);"));

    // Check JNI function signatures
    assert!(jni_code.contains("jintArray JNICALL"));
    assert!(jni_code.contains("jintArray values"));

    // Check array conversions
    assert!(jni_code.contains("GetArrayLength"));
    assert!(jni_code.contains("GetIntArrayElements"));
    assert!(jni_code.contains("ReleaseIntArrayElements"));
    assert!(jni_code.contains("NewIntArray"));
    assert!(jni_code.contains("SetIntArrayRegion"));

    // Check string array conversions
    assert!(jni_code.contains("GetObjectArrayElement"));
    assert!(jni_code.contains("NewObjectArray"));
    assert!(jni_code.contains("SetObjectArrayElement"));

    // Check vector construction
    assert!(jni_code.contains("std::vector<int> cpp_values"));
    assert!(jni_code.contains("std::vector<std::string> cpp_strings"));

    // Test 5: Generate CMake
    let cmake_code = generate_cmake(
        "arrays",
        &["ffi/cpp/arrays.cpp".to_string()],
        "build/jni/arrays_bridge.cpp",
        "17",
        &[],
        &[],
    );

    assert!(cmake_code.contains("project(\"arrays\")"));
    assert!(cmake_code.contains("ffi/cpp/arrays.cpp"));
    assert!(cmake_code.contains("build/jni/arrays_bridge.cpp"));
}

// ============================================================
// Phase 4: Rust FFI Tests
// ============================================================

#[test]
fn test_rust_ffi_end_to_end() {
    // Create a temporary directory with test Rust file
    let temp_dir = TempDir::new().unwrap();
    let ffi_dir = temp_dir.path().join("ffi");
    let rust_dir = ffi_dir.join("rust");
    fs::create_dir_all(&rust_dir).unwrap();

    // Write test Rust file
    let rust_content = r#"
#[ffi]
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[ffi]
pub fn multiply(x: i32, y: i32) -> i32 {
    x * y
}

#[ffi]
pub fn is_positive(n: i32) -> bool {
    n > 0
}

// Helper (not FFI)
fn helper(x: i32) -> i32 {
    x * 2
}
"#;
    fs::write(rust_dir.join("lib.rs"), rust_content).unwrap();

    // Test 1: Discover FFI functions
    let functions = discover_rust_ffi(&ffi_dir).unwrap();
    assert_eq!(functions.len(), 3, "Should find 3 #[ffi] functions");

    let function_names: Vec<_> = functions.iter().map(|f| f.name.as_str()).collect();
    assert!(function_names.contains(&"add"));
    assert!(function_names.contains(&"multiply"));
    assert!(function_names.contains(&"is_positive"));
    assert!(!function_names.contains(&"helper"), "helper should not be discovered");

    // Test 2: Generate Kotlin bindings
    let kotlin_code = generate_kotlin_object_rust(
        &functions,
        "com.example.test",
        "math",
        "Math",
    );

    assert!(kotlin_code.contains("package com.example.test"));
    assert!(kotlin_code.contains("object Math"));
    assert!(kotlin_code.contains("external fun add(a: Int, b: Int): Int"));
    assert!(kotlin_code.contains("external fun multiply(x: Int, y: Int): Int"));
    assert!(kotlin_code.contains("external fun isPositive(n: Int): Boolean"));
    assert!(kotlin_code.contains("System.loadLibrary(\"math\")"));
    assert!(kotlin_code.contains("Auto-generated by Whitehall FFI"));

    // Test 3: Generate Rust JNI bridge
    let rust_bridge_code = generate_rust_bridge(
        &functions,
        "com.example.test",
    );

    assert!(rust_bridge_code.contains("use jni::JNIEnv"));
    assert!(rust_bridge_code.contains("use jni::objects::{JClass"));
    assert!(rust_bridge_code.contains("#[no_mangle]"));
    assert!(rust_bridge_code.contains("pub extern \"system\" fn Java_com_example_test_add"));
    assert!(rust_bridge_code.contains("pub extern \"system\" fn Java_com_example_test_multiply"));
    assert!(rust_bridge_code.contains("pub extern \"system\" fn Java_com_example_test_isPositive"));
    assert!(rust_bridge_code.contains("crate::add(a, b)"));
    assert!(rust_bridge_code.contains("crate::multiply(x, y)"));
    assert!(rust_bridge_code.contains("crate::is_positive(n)"));
}

#[test]
fn test_rust_ffi_parser_primitives_only() {
    let temp_dir = TempDir::new().unwrap();
    let ffi_dir = temp_dir.path().join("ffi");
    let rust_dir = ffi_dir.join("rust");
    fs::create_dir_all(&rust_dir).unwrap();

    // Test all supported primitive types
    let rust_content = r#"
#[ffi]
pub fn test_int(x: i32) -> i32 { x }

#[ffi]
pub fn test_long(x: i64) -> i64 { x }

#[ffi]
pub fn test_float(x: f32) -> f32 { x }

#[ffi]
pub fn test_double(x: f64) -> f64 { x }

#[ffi]
pub fn test_bool(x: bool) -> bool { x }

#[ffi]
pub fn test_void(x: i32) { }
"#;
    fs::write(rust_dir.join("lib.rs"), rust_content).unwrap();

    let functions = discover_rust_ffi(&ffi_dir).unwrap();
    assert_eq!(functions.len(), 6);

    // Verify Kotlin type mapping
    let kotlin_code = generate_kotlin_object_rust(&functions, "com.test", "test", "Test");
    assert!(kotlin_code.contains("x: Int"));
    assert!(kotlin_code.contains("x: Long"));
    assert!(kotlin_code.contains("x: Float"));
    assert!(kotlin_code.contains("x: Double"));
    assert!(kotlin_code.contains("x: Boolean"));
    assert!(kotlin_code.contains("fun testVoid(x: Int)\n")); // No return type for void
}

#[test]
fn test_rust_ffi_string_support() {
    let temp_dir = TempDir::new().unwrap();
    let ffi_dir = temp_dir.path().join("ffi");
    let rust_dir = ffi_dir.join("rust");
    fs::create_dir_all(&rust_dir).unwrap();

    // Phase 4: String support
    let rust_content = r#"
#[ffi]
pub fn greet(name: String) -> String {
    format!("Hello, {}!", name)
}
"#;
    fs::write(rust_dir.join("lib.rs"), rust_content).unwrap();

    let result = discover_rust_ffi(&ffi_dir);
    assert!(result.is_ok(), "Phase 4 should support String");

    let functions = result.unwrap();
    assert_eq!(functions.len(), 1);
    assert_eq!(functions[0].name, "greet");
    assert_eq!(functions[0].return_type, whitehall::ffi_parser::rust::RustType::String);
    assert_eq!(functions[0].params[0].1, whitehall::ffi_parser::rust::RustType::String);
}

#[test]
fn test_rust_ffi_string_end_to_end() {
    // Create a temporary directory with test Rust file
    let temp_dir = TempDir::new().unwrap();
    let ffi_dir = temp_dir.path().join("ffi");
    let rust_dir = ffi_dir.join("rust");
    fs::create_dir_all(&rust_dir).unwrap();

    // Write test Rust file with string functions
    let rust_content = r#"
#[ffi]
pub fn greet(name: String) -> String {
    format!("Hello, {}!", name)
}

#[ffi]
pub fn to_upper(text: String) -> String {
    text.to_uppercase()
}

#[ffi]
pub fn format_number(format: String, number: i32) -> String {
    format!("{}{}", format, number)
}
"#;
    fs::write(rust_dir.join("lib.rs"), rust_content).unwrap();

    // Test 1: Discover FFI functions
    let functions = discover_rust_ffi(&ffi_dir).unwrap();
    assert_eq!(functions.len(), 3, "Should find 3 #[ffi] functions");

    // Test 2: Generate Kotlin bindings
    let kotlin_code = generate_kotlin_object_rust(
        &functions,
        "com.example.test",
        "strings",
        "Strings",
    );

    assert!(kotlin_code.contains("package com.example.test"));
    assert!(kotlin_code.contains("object Strings"));
    assert!(kotlin_code.contains("external fun greet(name: String): String"));
    assert!(kotlin_code.contains("external fun toUpper(text: String): String"));
    assert!(kotlin_code.contains("external fun formatNumber(format: String, number: Int): String"));
    assert!(kotlin_code.contains("System.loadLibrary(\"strings\")"));

    // Test 3: Generate Rust JNI bridge with string conversions
    let rust_bridge_code = generate_rust_bridge(
        &functions,
        "com.example.test",
    );

    // Check string conversions
    assert!(rust_bridge_code.contains("get_string"));
    assert!(rust_bridge_code.contains("new_string"));
    assert!(rust_bridge_code.contains("rust_name"));
    assert!(rust_bridge_code.contains("rust_text"));
    assert!(rust_bridge_code.contains("rust_format"));
}

#[test]
fn test_rust_ffi_array_end_to_end() {
    // Create a temporary directory with test Rust file
    let temp_dir = TempDir::new().unwrap();
    let ffi_dir = temp_dir.path().join("ffi");
    let rust_dir = ffi_dir.join("rust");
    fs::create_dir_all(&rust_dir).unwrap();

    // Write test Rust file with array functions
    let rust_content = r#"
#[ffi]
pub fn double_values(values: Vec<i32>) -> Vec<i32> {
    values.iter().map(|v| v * 2).collect()
}

#[ffi]
pub fn sum_array(values: Vec<i32>) -> i32 {
    values.iter().sum()
}

#[ffi]
pub fn to_upper_case(strings: Vec<String>) -> Vec<String> {
    strings.iter().map(|s| s.to_uppercase()).collect()
}
"#;
    fs::write(rust_dir.join("lib.rs"), rust_content).unwrap();

    // Test 1: Discover FFI functions
    let functions = discover_rust_ffi(&ffi_dir).unwrap();
    assert_eq!(functions.len(), 3, "Should find 3 #[ffi] functions");

    // Test 2: Check types are correct
    assert_eq!(functions[0].name, "double_values");
    assert_eq!(functions[0].params[0].1, whitehall::ffi_parser::rust::RustType::IntArray);
    assert_eq!(functions[0].return_type, whitehall::ffi_parser::rust::RustType::IntArray);

    assert_eq!(functions[1].name, "sum_array");
    assert_eq!(functions[1].params[0].1, whitehall::ffi_parser::rust::RustType::IntArray);
    assert_eq!(functions[1].return_type, whitehall::ffi_parser::rust::RustType::Int);

    assert_eq!(functions[2].name, "to_upper_case");
    assert_eq!(functions[2].params[0].1, whitehall::ffi_parser::rust::RustType::StringArray);
    assert_eq!(functions[2].return_type, whitehall::ffi_parser::rust::RustType::StringArray);

    // Test 3: Generate Kotlin bindings
    let kotlin_code = generate_kotlin_object_rust(
        &functions,
        "com.example.test",
        "arrays",
        "Arrays",
    );

    assert!(kotlin_code.contains("package com.example.test"));
    assert!(kotlin_code.contains("object Arrays"));
    assert!(kotlin_code.contains("external fun doubleValues(values: IntArray): IntArray"));
    assert!(kotlin_code.contains("external fun sumArray(values: IntArray): Int"));
    assert!(kotlin_code.contains("external fun toUpperCase(strings: Array<String>): Array<String>"));
    assert!(kotlin_code.contains("System.loadLibrary(\"arrays\")"));

    // Test 4: Generate Rust JNI bridge with array conversions
    let rust_bridge_code = generate_rust_bridge(
        &functions,
        "com.example.test",
    );

    println!("{}", rust_bridge_code);

    // Check JNI array functions
    assert!(rust_bridge_code.contains("jintArray"));
    assert!(rust_bridge_code.contains("get_int_array_elements"));
    assert!(rust_bridge_code.contains("new_int_array"));
    assert!(rust_bridge_code.contains("set_int_array_region"));

    // Check string array conversions
    assert!(rust_bridge_code.contains("get_object_array_element"));
    assert!(rust_bridge_code.contains("new_object_array"));
    assert!(rust_bridge_code.contains("set_object_array_element"));

    // Check vector construction
    assert!(rust_bridge_code.contains("rust_values"));
    assert!(rust_bridge_code.contains("rust_strings"));
}
