use std::path::Path;

/// Generate CMakeLists.txt for building the native library
pub fn generate_cmake(
    library_name: &str,
    source_files: &[String],
    bridge_file: &str,
    cpp_standard: &str,
    additional_flags: &[String],
    link_libraries: &[String],
) -> String {
    let mut output = String::new();

    // Header comment
    output.push_str("# Auto-generated by Whitehall FFI\n");
    output.push_str("# DO NOT EDIT MANUALLY\n\n");

    // CMake version
    output.push_str("cmake_minimum_required(VERSION 3.22.1)\n\n");

    // Project name
    output.push_str(&format!("project(\"{}\")\n\n", library_name));

    // Library definition
    output.push_str(&format!("add_library({} SHARED\n", library_name));

    // Add user source files
    for source_file in source_files {
        output.push_str(&format!("    ${{CMAKE_SOURCE_DIR}}/{}\n", source_file));
    }

    // Add generated bridge file
    output.push_str(&format!("    {}\n", bridge_file));

    output.push_str(")\n\n");

    // C++ standard
    output.push_str(&format!("set(CMAKE_CXX_STANDARD {})\n", cpp_standard));
    output.push_str("set(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n");

    // Compiler flags
    if !additional_flags.is_empty() {
        output.push_str("target_compile_options(");
        output.push_str(library_name);
        output.push_str(" PRIVATE\n");
        for flag in additional_flags {
            output.push_str(&format!("    {}\n", flag));
        }
        output.push_str(")\n\n");
    }

    // Link libraries
    if !link_libraries.is_empty() {
        output.push_str("# Link external libraries\n");
        for lib in link_libraries {
            output.push_str(&format!("find_library({}-lib {})\n", lib, lib));
        }
        output.push_str(&format!("target_link_libraries({}", library_name));
        for lib in link_libraries {
            output.push_str(&format!(" ${{{}-lib}}", lib));
        }
        output.push_str(")\n\n");
    }

    // Always link log library (Android logging)
    output.push_str("# Android log library\n");
    output.push_str("find_library(log-lib log)\n");
    output.push_str(&format!("target_link_libraries({} ${{log-lib}})\n", library_name));

    output
}

/// Generate default CMakeLists.txt with minimal configuration
pub fn generate_default_cmake(library_name: &str, source_files: &[String], bridge_file: &str) -> String {
    generate_cmake(
        library_name,
        source_files,
        bridge_file,
        "17",        // Default C++ standard
        &[],         // No additional flags
        &[],         // No additional libraries
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_minimal_cmake() {
        let cmake = generate_default_cmake(
            "math",
            &["src/ffi/cpp/math.cpp".to_string()],
            "build/jni/math_bridge.cpp",
        );

        println!("{}", cmake);

        assert!(cmake.contains("cmake_minimum_required(VERSION 3.22.1)"));
        assert!(cmake.contains("project(\"math\")"));
        assert!(cmake.contains("add_library(math SHARED"));
        assert!(cmake.contains("src/ffi/cpp/math.cpp"));
        assert!(cmake.contains("build/jni/math_bridge.cpp"));
        assert!(cmake.contains("set(CMAKE_CXX_STANDARD 17)"));
        assert!(cmake.contains("find_library(log-lib log)"));
        assert!(cmake.contains("target_link_libraries(math ${log-lib})"));
        assert!(cmake.contains("Auto-generated by Whitehall FFI"));
    }

    #[test]
    fn test_generate_cmake_with_flags() {
        let cmake = generate_cmake(
            "mylib",
            &["src/code.cpp".to_string()],
            "build/bridge.cpp",
            "20",
            &["-O3".to_string(), "-Wall".to_string(), "-Werror".to_string()],
            &[],
        );

        assert!(cmake.contains("set(CMAKE_CXX_STANDARD 20)"));
        assert!(cmake.contains("target_compile_options(mylib PRIVATE"));
        assert!(cmake.contains("-O3"));
        assert!(cmake.contains("-Wall"));
        assert!(cmake.contains("-Werror"));
    }

    #[test]
    fn test_generate_cmake_with_libraries() {
        let cmake = generate_cmake(
            "vision",
            &["src/vision.cpp".to_string()],
            "build/bridge.cpp",
            "17",
            &[],
            &["opencv".to_string(), "ffmpeg".to_string()],
        );

        assert!(cmake.contains("find_library(opencv-lib opencv)"));
        assert!(cmake.contains("find_library(ffmpeg-lib ffmpeg)"));
        assert!(cmake.contains("target_link_libraries(vision ${opencv-lib} ${ffmpeg-lib})"));
    }

    #[test]
    fn test_generate_cmake_multiple_sources() {
        let cmake = generate_default_cmake(
            "multifile",
            &[
                "src/ffi/cpp/math.cpp".to_string(),
                "src/ffi/cpp/utils.cpp".to_string(),
                "src/ffi/cpp/helpers.cpp".to_string(),
            ],
            "build/bridge.cpp",
        );

        assert!(cmake.contains("src/ffi/cpp/math.cpp"));
        assert!(cmake.contains("src/ffi/cpp/utils.cpp"));
        assert!(cmake.contains("src/ffi/cpp/helpers.cpp"));
    }

    #[test]
    fn test_generate_cmake_full_config() {
        let cmake = generate_cmake(
            "fulltest",
            &["src/main.cpp".to_string()],
            "build/gen.cpp",
            "20",
            &["-O3".to_string(), "-fno-exceptions".to_string()],
            &["z".to_string(), "m".to_string()],
        );

        // Check all components are present
        assert!(cmake.contains("project(\"fulltest\")"));
        assert!(cmake.contains("CMAKE_CXX_STANDARD 20"));
        assert!(cmake.contains("target_compile_options"));
        assert!(cmake.contains("-O3"));
        assert!(cmake.contains("-fno-exceptions"));
        assert!(cmake.contains("find_library(z-lib z)"));
        assert!(cmake.contains("find_library(m-lib m)"));
        assert!(cmake.contains("${z-lib}"));
        assert!(cmake.contains("${m-lib}"));
        assert!(cmake.contains("${log-lib}"));
    }
}
