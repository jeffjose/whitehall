use crate::ffi_parser::rust::{RustFfiFunction, RustType};

/// Convert snake_case to camelCase
fn snake_to_camel(name: &str) -> String {
    let mut result = String::new();
    let mut capitalize_next = false;

    for ch in name.chars() {
        if ch == '_' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(ch.to_ascii_uppercase());
            capitalize_next = false;
        } else {
            result.push(ch);
        }
    }

    result
}

/// Generate complete Rust JNI bridge for all functions
pub fn generate_rust_bridge(
    functions: &[RustFfiFunction],
    package: &str,
) -> String {
    let mut output = String::new();

    // Header with imports
    output.push_str("// Auto-generated by Whitehall FFI (Rust)\n");
    output.push_str("// DO NOT EDIT MANUALLY\n\n");
    output.push_str("use jni::JNIEnv;\n");
    output.push_str("use jni::objects::{JClass, JString, JObject};\n");
    output.push_str("use jni::sys::*;\n\n");

    // Generate each function
    for function in functions {
        output.push_str(&generate_rust_bridge_function(function, package));
        output.push('\n');
    }

    output
}

/// Generate a single JNI bridge function in Rust
fn generate_rust_bridge_function(function: &RustFfiFunction, package: &str) -> String {
    let mut output = String::new();

    // JNI function name: Java_com_example_package_ClassName_functionName
    // Convert to camelCase to match Kotlin convention
    let kotlin_name = snake_to_camel(&function.name);
    let jni_name = format!(
        "Java_{}_{}",
        package.replace('.', "_"),
        kotlin_name
    );

    // Build parameter list
    let mut jni_params = vec!["env: JNIEnv".to_string(), "_class: JClass".to_string()];

    for (param_name, param_type) in &function.params {
        jni_params.push(format!("{}: {}", param_name, param_type.to_jni_type()));
    }

    // Return type
    let return_type = function.return_type.to_jni_type();

    // Function signature
    output.push_str("#[no_mangle]\n");
    output.push_str(&format!(
        "pub extern \"system\" fn {}(\n",
        jni_name
    ));

    for (i, param) in jni_params.iter().enumerate() {
        if i == jni_params.len() - 1 {
            output.push_str(&format!("    {}\n", param));
        } else {
            output.push_str(&format!("    {},\n", param));
        }
    }

    output.push_str(&format!(") -> {} {{\n", return_type));

    // Function body with type conversions
    generate_function_body(&mut output, function);

    output.push_str("}\n");

    output
}

/// Generate the function body with proper type conversions
fn generate_function_body(output: &mut String, function: &RustFfiFunction) {
    let _has_complex_types = function.params.iter().any(|(_, typ)| is_complex_type(typ))
        || is_complex_type(&function.return_type.base_type);

    // Convert parameters
    for (param_name, param_type) in &function.params {
        if is_complex_type(param_type) {
            generate_param_conversion(output, param_name, param_type);
        }
    }

    // Build function call
    let mut call_params = Vec::new();
    for (param_name, param_type) in &function.params {
        if is_complex_type(param_type) {
            call_params.push(format!("rust_{}", param_name));
        } else {
            call_params.push(param_name.clone());
        }
    }

    let call_expr = if call_params.is_empty() {
        format!("crate::{}()", function.name)
    } else {
        format!("crate::{}({})", function.name, call_params.join(", "))
    };

    // Phase 5: Handle Result<T, E> types
    if function.return_type.is_result {
        output.push_str(&format!("    match {} {{\n", call_expr));
        output.push_str("        Ok(value) => {\n");

        // Handle successful result
        match function.return_type.base_type {
            RustType::Void => {
                output.push_str("            // Void result\n");
            }
            RustType::Bool => {
                // Boolean needs conversion from bool to jboolean (u8)
                output.push_str("            value as jboolean\n");
            }
            ref ret_type if !is_complex_type(ret_type) => {
                output.push_str("            value\n");
            }
            ref ret_type => {
                output.push_str("            let result = value;\n");
                generate_return_conversion(output, ret_type);
            }
        }
        output.push_str("        }\n");

        // Handle error case - throw Java exception
        output.push_str("        Err(e) => {\n");
        output.push_str("            let err_msg = format!(\"{}\", e);\n");
        output.push_str("            let err_str = env.new_string(err_msg)\n");
        output.push_str("                .expect(\"Couldn't create error string!\");\n");
        output.push_str("            env.throw_new(\"java/lang/RuntimeException\", err_str.to_str().unwrap_or(\"\"))\n");
        output.push_str("                .expect(\"Couldn't throw exception!\");\n");
        output.push_str(&generate_default_return_for_result(&function.return_type.base_type));
        output.push_str("        }\n");
        output.push_str("    }\n");
    } else {
        // Not a Result - handle normally
        match function.return_type.base_type {
            RustType::Void => {
                output.push_str(&format!("    {};\n", call_expr));
            }
            RustType::Bool => {
                // Boolean needs conversion from bool to jboolean (u8)
                output.push_str(&format!("    {} as jboolean\n", call_expr));
            }
            ref ret_type if !is_complex_type(ret_type) => {
                // Simple return - direct pass-through
                output.push_str(&format!("    {}\n", call_expr));
            }
            ref ret_type => {
                // Complex return - needs conversion
                output.push_str(&format!("    let result = {};\n", call_expr));
                generate_return_conversion(output, ret_type);
            }
        }
    }
}

/// Generate default return value for Result error cases
fn generate_default_return_for_result(base_type: &RustType) -> String {
    match base_type {
        RustType::Void => String::new(),
        RustType::Int | RustType::Long => "            0\n".to_string(),
        RustType::Float | RustType::Double => "            0.0\n".to_string(),
        RustType::Bool => "            false\n".to_string(),
        RustType::String | RustType::IntArray | RustType::LongArray |
        RustType::FloatArray | RustType::DoubleArray | RustType::BoolArray |
        RustType::StringArray => "            JObject::null().into_inner()\n".to_string(),
    }
}

/// Check if a type needs conversion (not a simple primitive)
fn is_complex_type(typ: &RustType) -> bool {
    matches!(
        typ,
        RustType::String
            | RustType::IntArray
            | RustType::LongArray
            | RustType::FloatArray
            | RustType::DoubleArray
            | RustType::BoolArray
            | RustType::StringArray
    )
}

/// Generate parameter conversion code
fn generate_param_conversion(output: &mut String, param_name: &str, param_type: &RustType) {
    match param_type {
        RustType::String => {
            output.push_str(&format!(
                "    let rust_{}: String = env\n",
                param_name
            ));
            output.push_str(&format!(
                "        .get_string(JString::from({}))\n",
                param_name
            ));
            output.push_str("        .expect(\"Couldn't get Java string!\")\n");
            output.push_str("        .into();\n");
        }
        RustType::IntArray | RustType::LongArray | RustType::FloatArray
        | RustType::DoubleArray | RustType::BoolArray => {
            generate_primitive_array_conversion(output, param_name, param_type);
        }
        RustType::StringArray => {
            generate_string_array_conversion(output, param_name);
        }
        _ => {}
    }
}

/// Generate primitive array parameter conversion
fn generate_primitive_array_conversion(
    output: &mut String,
    param_name: &str,
    param_type: &RustType,
) {
    let (get_fn, rust_elem_type) = match param_type {
        RustType::IntArray => ("get_int_array_elements", "i32"),
        RustType::LongArray => ("get_long_array_elements", "i64"),
        RustType::FloatArray => ("get_float_array_elements", "f32"),
        RustType::DoubleArray => ("get_double_array_elements", "f64"),
        RustType::BoolArray => ("get_boolean_array_elements", "bool"),
        _ => unreachable!(),
    };

    output.push_str(&format!(
        "    let rust_{}: Vec<{}> = env.{}({})\n",
        param_name, rust_elem_type, get_fn, param_name
    ));
    output.push_str("        .expect(\"Couldn't get array elements!\")\n");
    output.push_str("        .to_vec();\n");
}

/// Generate string array parameter conversion
fn generate_string_array_conversion(output: &mut String, param_name: &str) {
    output.push_str(&format!("    let len = env.get_array_length({})\n", param_name));
    output.push_str("        .expect(\"Couldn't get array length!\") as usize;\n");
    output.push_str(&format!("    let mut rust_{}: Vec<String> = Vec::with_capacity(len);\n", param_name));
    output.push_str("    for i in 0..len {\n");
    output.push_str(&format!("        let elem = env.get_object_array_element({}, i as i32)\n", param_name));
    output.push_str("            .expect(\"Couldn't get array element!\");\n");
    output.push_str("        let jstr = JString::from(elem);\n");
    output.push_str("        let rust_str: String = env.get_string(jstr)\n");
    output.push_str("            .expect(\"Couldn't get string!\")\n");
    output.push_str("            .into();\n");
    output.push_str(&format!("        rust_{}.push(rust_str);\n", param_name));
    output.push_str("    }\n");
}

/// Generate return value conversion code
fn generate_return_conversion(output: &mut String, return_type: &RustType) {
    match return_type {
        RustType::String => {
            output.push_str("    env.new_string(result)\n");
            output.push_str("        .expect(\"Couldn't create Java string!\")\n");
            output.push_str("        .into_inner()\n");
        }
        RustType::IntArray | RustType::LongArray | RustType::FloatArray
        | RustType::DoubleArray | RustType::BoolArray => {
            generate_primitive_array_return(output, return_type);
        }
        RustType::StringArray => {
            generate_string_array_return(output);
        }
        _ => {}
    }
}

/// Generate primitive array return conversion
fn generate_primitive_array_return(output: &mut String, return_type: &RustType) {
    let new_array_fn = match return_type {
        RustType::IntArray => "new_int_array",
        RustType::LongArray => "new_long_array",
        RustType::FloatArray => "new_float_array",
        RustType::DoubleArray => "new_double_array",
        RustType::BoolArray => "new_boolean_array",
        _ => unreachable!(),
    };

    let set_region_fn = match return_type {
        RustType::IntArray => "set_int_array_region",
        RustType::LongArray => "set_long_array_region",
        RustType::FloatArray => "set_float_array_region",
        RustType::DoubleArray => "set_double_array_region",
        RustType::BoolArray => "set_boolean_array_region",
        _ => unreachable!(),
    };

    output.push_str(&format!(
        "    let output = env.{}(result.len() as i32)\n",
        new_array_fn
    ));
    output.push_str("        .expect(\"Couldn't create array!\");\n");
    output.push_str(&format!(
        "    env.{}(output, 0, &result)\n",
        set_region_fn
    ));
    output.push_str("        .expect(\"Couldn't set array region!\");\n");
    output.push_str("    output\n");
}

/// Generate string array return conversion
fn generate_string_array_return(output: &mut String) {
    output.push_str("    let string_class = env.find_class(\"java/lang/String\")\n");
    output.push_str("        .expect(\"Couldn't find String class!\");\n");
    output.push_str("    let output = env.new_object_array(\n");
    output.push_str("        result.len() as i32,\n");
    output.push_str("        string_class,\n");
    output.push_str("        JObject::null()\n");
    output.push_str("    ).expect(\"Couldn't create object array!\");\n");
    output.push_str("    for (i, s) in result.iter().enumerate() {\n");
    output.push_str("        let jstr = env.new_string(s)\n");
    output.push_str("            .expect(\"Couldn't create string!\");\n");
    output.push_str("        env.set_object_array_element(output, i as i32, jstr)\n");
    output.push_str("            .expect(\"Couldn't set array element!\");\n");
    output.push_str("    }\n");
    output.push_str("    output\n");
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_generate_simple_function() {
        let func = RustFfiFunction {
            name: "add".to_string(),
            params: vec![
                ("a".to_string(), RustType::Int),
                ("b".to_string(), RustType::Int),
            ],
            return_type: RustFunctionReturn::plain(RustType::Int),
            source_file: PathBuf::from("lib.rs"),
        };

        let bridge = generate_rust_bridge(&vec![func], "com.example.ffi");

        assert!(bridge.contains("use jni::JNIEnv"));
        assert!(bridge.contains("use jni::objects::{JClass"));
        assert!(bridge.contains("#[no_mangle]"));
        assert!(bridge.contains("pub extern \"system\" fn Java_com_example_ffi_add"));
        assert!(bridge.contains("a: jint"));
        assert!(bridge.contains("b: jint"));
        assert!(bridge.contains("-> jint"));
        assert!(bridge.contains("crate::add(a, b)"));
    }

    #[test]
    fn test_generate_string_function() {
        let func = RustFfiFunction {
            name: "greet".to_string(),
            params: vec![("name".to_string(), RustType::String)],
            return_type: RustFunctionReturn::plain(RustType::String),
            source_file: PathBuf::from("lib.rs"),
        };

        let bridge = generate_rust_bridge(&vec![func], "com.example.ffi");

        assert!(bridge.contains("name: jstring"));
        assert!(bridge.contains("-> jstring"));
        assert!(bridge.contains("get_string"));
        assert!(bridge.contains("new_string"));
        assert!(bridge.contains("rust_name"));
    }

    #[test]
    fn test_generate_array_function() {
        let func = RustFfiFunction {
            name: "double_values".to_string(),
            params: vec![("values".to_string(), RustType::IntArray)],
            return_type: RustFunctionReturn::plain(RustType::IntArray),
            source_file: PathBuf::from("lib.rs"),
        };

        let bridge = generate_rust_bridge(&vec![func], "com.example.ffi");

        assert!(bridge.contains("values: jintArray"));
        assert!(bridge.contains("-> jintArray"));
        assert!(bridge.contains("get_int_array_elements"));
        assert!(bridge.contains("new_int_array"));
        assert!(bridge.contains("set_int_array_region"));
    }
}
