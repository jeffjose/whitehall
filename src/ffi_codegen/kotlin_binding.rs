use crate::ffi_parser::cpp::{CppFfiFunction, CppType};
use crate::ffi_parser::rust::{RustFfiFunction, RustType};

/// Generate a single Kotlin external function declaration
pub fn generate_kotlin_binding(function: &CppFfiFunction) -> String {
    let params = function
        .params
        .iter()
        .map(|(name, typ)| format!("{}: {}", name, typ.to_kotlin_type()))
        .collect::<Vec<_>>()
        .join(", ");

    let return_type = match function.return_type {
        CppType::Void => String::new(),
        _ => format!(": {}", function.return_type.to_kotlin_type()),
    };

    // Convert snake_case to camelCase for Kotlin convention
    let kotlin_name = snake_to_camel(&function.name);

    format!(
        "    external fun {}({}){}\n",
        kotlin_name, params, return_type
    )
}

/// Generate a complete Kotlin object with all FFI functions
pub fn generate_kotlin_object(
    functions: &[CppFfiFunction],
    package: &str,
    library_name: &str,
    object_name: &str,
) -> String {
    let mut output = String::new();

    // Package declaration
    output.push_str(&format!("package {}\n\n", package));

    // Auto-generated comment
    output.push_str("/**\n");
    output.push_str(" * Auto-generated by Whitehall FFI\n");
    output.push_str(" * DO NOT EDIT MANUALLY\n");
    output.push_str(" */\n");

    // Object declaration
    output.push_str(&format!("object {} {{\n", object_name));

    // External function declarations
    for function in functions {
        output.push_str(&generate_kotlin_binding(function));
    }

    output.push('\n');

    // init block to load library
    output.push_str("    init {\n");
    output.push_str(&format!("        System.loadLibrary(\"{}\")\n", library_name));
    output.push_str("    }\n");

    // Close object
    output.push_str("}\n");

    output
}

/// Convert snake_case to camelCase
fn snake_to_camel(name: &str) -> String {
    let mut result = String::new();
    let mut capitalize_next = false;

    for ch in name.chars() {
        if ch == '_' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(ch.to_ascii_uppercase());
            capitalize_next = false;
        } else {
            result.push(ch);
        }
    }

    result
}

/// Generate a single Kotlin external function declaration from Rust function
pub fn generate_kotlin_binding_rust(function: &RustFfiFunction) -> String {
    let params = function
        .params
        .iter()
        .map(|(name, typ)| format!("{}: {}", name, typ.to_kotlin_type()))
        .collect::<Vec<_>>()
        .join(", ");

    let return_type = match function.return_type.base_type {
        RustType::Void => String::new(),
        _ => format!(": {}", function.return_type.to_kotlin_type()),
    };

    // Convert snake_case to camelCase for Kotlin convention
    let kotlin_name = snake_to_camel(&function.name);

    format!(
        "    external fun {}({}){}\n",
        kotlin_name, params, return_type
    )
}

/// Generate a complete Kotlin object with all Rust FFI functions
pub fn generate_kotlin_object_rust(
    functions: &[RustFfiFunction],
    package: &str,
    library_name: &str,
    object_name: &str,
) -> String {
    let mut output = String::new();

    // Package declaration
    output.push_str(&format!("package {}\n\n", package));

    // Auto-generated comment
    output.push_str("/**\n");
    output.push_str(" * Auto-generated by Whitehall FFI (Rust)\n");
    output.push_str(" * DO NOT EDIT MANUALLY\n");
    output.push_str(" */\n");

    // Object declaration
    output.push_str(&format!("object {} {{\n", object_name));

    // External function declarations
    for function in functions {
        output.push_str(&generate_kotlin_binding_rust(function));
    }

    output.push('\n');

    // init block to load library
    output.push_str("    init {\n");
    output.push_str(&format!("        System.loadLibrary(\"{}\")\n", library_name));
    output.push_str("    }\n");

    // Close object
    output.push_str("}\n");

    output
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_generate_simple_binding() {
        let func = CppFfiFunction {
            name: "add".to_string(),
            params: vec![
                ("a".to_string(), CppType::Int),
                ("b".to_string(), CppType::Int),
            ],
            return_type: CppType::Int,
            source_file: PathBuf::from("test.cpp"),
        };

        let kotlin = generate_kotlin_binding(&func);
        assert_eq!(kotlin, "    external fun add(a: Int, b: Int): Int\n");
    }

    #[test]
    fn test_generate_no_params() {
        let func = CppFfiFunction {
            name: "getRandom".to_string(),
            params: vec![],
            return_type: CppType::Int,
            source_file: PathBuf::from("test.cpp"),
        };

        let kotlin = generate_kotlin_binding(&func);
        assert_eq!(kotlin, "    external fun getRandom(): Int\n");
    }

    #[test]
    fn test_generate_void_return() {
        let func = CppFfiFunction {
            name: "doSomething".to_string(),
            params: vec![("x".to_string(), CppType::Int)],
            return_type: CppType::Void,
            source_file: PathBuf::from("test.cpp"),
        };

        let kotlin = generate_kotlin_binding(&func);
        assert_eq!(kotlin, "    external fun doSomething(x: Int)\n");
    }

    #[test]
    fn test_generate_complete_object() {
        let functions = vec![
            CppFfiFunction {
                name: "add".to_string(),
                params: vec![
                    ("a".to_string(), CppType::Int),
                    ("b".to_string(), CppType::Int),
                ],
                return_type: CppType::Int,
                source_file: PathBuf::from("math.cpp"),
            },
            CppFfiFunction {
                name: "multiply".to_string(),
                params: vec![
                    ("x".to_string(), CppType::Double),
                    ("y".to_string(), CppType::Double),
                ],
                return_type: CppType::Double,
                source_file: PathBuf::from("math.cpp"),
            },
        ];

        let kotlin = generate_kotlin_object(&functions, "com.example.ffi", "math", "Math");

        assert!(kotlin.contains("package com.example.ffi"));
        assert!(kotlin.contains("object Math {"));
        assert!(kotlin.contains("external fun add(a: Int, b: Int): Int"));
        assert!(kotlin.contains("external fun multiply(x: Double, y: Double): Double"));
        assert!(kotlin.contains("System.loadLibrary(\"math\")"));
        assert!(kotlin.contains("Auto-generated by Whitehall FFI"));
    }

    #[test]
    fn test_all_types() {
        let functions = vec![
            CppFfiFunction {
                name: "testInt".to_string(),
                params: vec![("a".to_string(), CppType::Int)],
                return_type: CppType::Int,
                source_file: PathBuf::from("test.cpp"),
            },
            CppFfiFunction {
                name: "testLong".to_string(),
                params: vec![("a".to_string(), CppType::Long)],
                return_type: CppType::Long,
                source_file: PathBuf::from("test.cpp"),
            },
            CppFfiFunction {
                name: "testFloat".to_string(),
                params: vec![("a".to_string(), CppType::Float)],
                return_type: CppType::Float,
                source_file: PathBuf::from("test.cpp"),
            },
            CppFfiFunction {
                name: "testDouble".to_string(),
                params: vec![("a".to_string(), CppType::Double)],
                return_type: CppType::Double,
                source_file: PathBuf::from("test.cpp"),
            },
            CppFfiFunction {
                name: "testBool".to_string(),
                params: vec![("a".to_string(), CppType::Bool)],
                return_type: CppType::Bool,
                source_file: PathBuf::from("test.cpp"),
            },
        ];

        let kotlin = generate_kotlin_object(&functions, "com.test", "test", "Test");

        assert!(kotlin.contains("a: Int"));
        assert!(kotlin.contains("a: Long"));
        assert!(kotlin.contains("a: Float"));
        assert!(kotlin.contains("a: Double"));
        assert!(kotlin.contains("a: Boolean"));
        assert!(kotlin.contains(": Int"));
        assert!(kotlin.contains(": Long"));
        assert!(kotlin.contains(": Float"));
        assert!(kotlin.contains(": Double"));
        assert!(kotlin.contains(": Boolean"));
    }
}
