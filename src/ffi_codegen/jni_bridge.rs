use crate::ffi_parser::cpp::{CppFfiFunction, CppType};

/// Generate JNI bridge code for all FFI functions
pub fn generate_jni_bridge(
    functions: &[CppFfiFunction],
    package: &str,
    source_files: &[String],
) -> String {
    let mut output = String::new();

    // Header comment
    output.push_str("/*\n");
    output.push_str(" * Auto-generated by Whitehall FFI\n");
    output.push_str(" * DO NOT EDIT MANUALLY\n");
    output.push_str(" */\n\n");

    // Include JNI header
    output.push_str("#include <jni.h>\n\n");

    // Include user source files
    for source_file in source_files {
        output.push_str(&format!("// User code\n"));
        output.push_str(&format!("#include \"{}\"\n", source_file));
    }
    output.push_str("\n");

    // Generate forward declarations for user functions
    output.push_str("// Forward declarations of user functions\n");
    for function in functions {
        output.push_str(&generate_forward_declaration(function));
    }
    output.push_str("\n");

    // Generate JNI bridge functions
    for function in functions {
        output.push_str(&generate_jni_function(function, package));
        output.push_str("\n");
    }

    output
}

/// Generate forward declaration for a user function
fn generate_forward_declaration(function: &CppFfiFunction) -> String {
    let params = function
        .params
        .iter()
        .map(|(_, typ)| {
            // For String parameters, use const reference
            if *typ == CppType::String {
                "const std::string&"
            } else {
                typ.to_cpp_type()
            }
        })
        .collect::<Vec<_>>()
        .join(", ");

    format!(
        "{} {}({});\n",
        function.return_type.to_cpp_type(),
        function.name,
        params
    )
}

/// Generate JNI function wrapper
fn generate_jni_function(function: &CppFfiFunction, package: &str) -> String {
    let mut output = String::new();

    // Generate JNI function name
    let jni_name = generate_jni_name(&function.name, package);
    let jni_return_type = function.return_type.to_jni_type();

    // Function signature
    output.push_str("extern \"C\" JNIEXPORT ");
    output.push_str(jni_return_type);
    output.push_str(" JNICALL\n");
    output.push_str(&jni_name);
    output.push_str("(\n");
    output.push_str("    JNIEnv* env,\n");
    output.push_str("    jobject thiz");

    // Add parameters
    for (param_name, param_type) in function.params.iter() {
        output.push_str(",\n");
        output.push_str(&format!(
            "    {} {}",
            param_type.to_jni_type(),
            param_name
        ));
    }

    output.push_str("\n) {\n");

    // Check if we have any string parameters or return types
    let has_strings = function.params.iter().any(|(_, t)| *t == CppType::String)
        || function.return_type == CppType::String;

    if has_strings {
        // Phase 2: Handle string conversions
        output.push_str(&generate_string_conversions(function));
    } else {
        // Phase 1: Direct call for primitives
        output.push_str("    // Call user function\n");

        if function.return_type == CppType::Void {
            output.push_str(&format!("    {}(", function.name));
        } else {
            output.push_str(&format!("    return {}(", function.name));
        }

        // Pass parameters
        let param_names: Vec<String> = function
            .params
            .iter()
            .map(|(name, _)| name.clone())
            .collect();
        output.push_str(&param_names.join(", "));
        output.push_str(");\n");
    }

    output.push_str("}\n");

    output
}

/// Generate string conversion code for JNI bridge (Phase 2)
fn generate_string_conversions(function: &CppFfiFunction) -> String {
    let mut output = String::new();

    // Convert string parameters from jstring to std::string
    for (param_name, param_type) in function.params.iter() {
        if *param_type == CppType::String {
            output.push_str(&format!(
                "    // Convert jstring to std::string\n"));
            output.push_str(&format!(
                "    if ({} == nullptr) {{\n", param_name));
            output.push_str("        // TODO: Handle null string - throw exception or return default\n");
            output.push_str(&format!(
                "        {} = env->NewStringUTF(\"\");\n", param_name));
            output.push_str("    }\n");

            output.push_str(&format!(
                "    const char* c_{} = env->GetStringUTFChars({}, nullptr);\n",
                param_name, param_name));
            output.push_str(&format!(
                "    if (c_{} == nullptr) {{\n", param_name));
            output.push_str("        return ");
            if function.return_type == CppType::Void {
                output.push_str(";\n");
            } else if function.return_type == CppType::String {
                output.push_str("env->NewStringUTF(\"\");\n");
            } else {
                output.push_str("0;  // OutOfMemoryError\n");
            }
            output.push_str("    }\n");

            output.push_str(&format!(
                "    std::string cpp_{}(c_{});\n",
                param_name, param_name));
            output.push_str(&format!(
                "    env->ReleaseStringUTFChars({}, c_{});\n\n",
                param_name, param_name));
        }
    }

    // Call the user function
    output.push_str("    // Call user function\n");
    if function.return_type == CppType::String {
        output.push_str(&format!("    std::string result = {}(", function.name));
    } else if function.return_type == CppType::Void {
        output.push_str(&format!("    {}(", function.name));
    } else {
        output.push_str(&format!("    return {}(", function.name));
    }

    // Pass converted parameters
    let param_calls: Vec<String> = function
        .params
        .iter()
        .map(|(name, typ)| {
            if *typ == CppType::String {
                format!("cpp_{}", name)
            } else {
                name.clone()
            }
        })
        .collect();
    output.push_str(&param_calls.join(", "));
    output.push_str(");\n");

    // Convert string return value to jstring
    if function.return_type == CppType::String {
        output.push_str("\n    // Convert std::string to jstring\n");
        output.push_str("    jstring j_result = env->NewStringUTF(result.c_str());\n");
        output.push_str("    if (j_result == nullptr) {\n");
        output.push_str("        return nullptr;  // OutOfMemoryError\n");
        output.push_str("    }\n");
        output.push_str("    return j_result;\n");
    }

    output
}

/// Generate JNI function name from Kotlin package and function name
/// Format: Java_com_example_ffi_ClassName_methodName
fn generate_jni_name(function_name: &str, package: &str) -> String {
    // Replace dots with underscores and add class name
    let package_path = package.replace('.', "_");
    // For now, we'll use "Math" as the default class name
    // TODO: Make this configurable or derive from source file
    format!("Java_{}_Math_{}", package_path, function_name)
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_generate_simple_jni_function() {
        let func = CppFfiFunction {
            name: "add".to_string(),
            params: vec![
                ("a".to_string(), CppType::Int),
                ("b".to_string(), CppType::Int),
            ],
            return_type: CppType::Int,
            source_file: PathBuf::from("math.cpp"),
        };

        let functions = vec![func];
        let bridge = generate_jni_bridge(&functions, "com.example.ffi", &["math.cpp".to_string()]);

        println!("{}", bridge);

        assert!(bridge.contains("#include <jni.h>"));
        assert!(bridge.contains("#include \"math.cpp\""));
        assert!(bridge.contains("int add(int, int);"));
        assert!(bridge.contains("Java_com_example_ffi_Math_add"));
        assert!(bridge.contains("jint"));
        assert!(bridge.contains("return add(a, b);"));
    }

    #[test]
    fn test_generate_no_params_function() {
        let func = CppFfiFunction {
            name: "getRandom".to_string(),
            params: vec![],
            return_type: CppType::Int,
            source_file: PathBuf::from("random.cpp"),
        };

        let functions = vec![func];
        let bridge = generate_jni_bridge(&functions, "com.test", &["random.cpp".to_string()]);

        assert!(bridge.contains("int getRandom();"));
        assert!(bridge.contains("return getRandom();"));
    }

    #[test]
    fn test_generate_void_return() {
        let func = CppFfiFunction {
            name: "doSomething".to_string(),
            params: vec![("x".to_string(), CppType::Int)],
            return_type: CppType::Void,
            source_file: PathBuf::from("test.cpp"),
        };

        let functions = vec![func];
        let bridge = generate_jni_bridge(&functions, "com.test", &["test.cpp".to_string()]);

        assert!(bridge.contains("void doSomething(int);"));
        assert!(bridge.contains("void JNICALL"));
        assert!(bridge.contains("doSomething(x);"));
        assert!(!bridge.contains("return doSomething"));
    }

    #[test]
    fn test_multiple_functions() {
        let functions = vec![
            CppFfiFunction {
                name: "add".to_string(),
                params: vec![
                    ("a".to_string(), CppType::Int),
                    ("b".to_string(), CppType::Int),
                ],
                return_type: CppType::Int,
                source_file: PathBuf::from("math.cpp"),
            },
            CppFfiFunction {
                name: "multiply".to_string(),
                params: vec![
                    ("x".to_string(), CppType::Double),
                    ("y".to_string(), CppType::Double),
                ],
                return_type: CppType::Double,
                source_file: PathBuf::from("math.cpp"),
            },
        ];

        let bridge = generate_jni_bridge(&functions, "com.example", &["math.cpp".to_string()]);

        assert!(bridge.contains("int add(int, int);"));
        assert!(bridge.contains("double multiply(double, double);"));
        assert!(bridge.contains("Java_com_example_Math_add"));
        assert!(bridge.contains("Java_com_example_Math_multiply"));
    }

    #[test]
    fn test_all_types() {
        let functions = vec![
            CppFfiFunction {
                name: "testBool".to_string(),
                params: vec![("b".to_string(), CppType::Bool)],
                return_type: CppType::Bool,
                source_file: PathBuf::from("test.cpp"),
            },
            CppFfiFunction {
                name: "testFloat".to_string(),
                params: vec![("f".to_string(), CppType::Float)],
                return_type: CppType::Float,
                source_file: PathBuf::from("test.cpp"),
            },
            CppFfiFunction {
                name: "testLong".to_string(),
                params: vec![("l".to_string(), CppType::Long)],
                return_type: CppType::Long,
                source_file: PathBuf::from("test.cpp"),
            },
        ];

        let bridge = generate_jni_bridge(&functions, "com.test", &["test.cpp".to_string()]);

        assert!(bridge.contains("bool testBool(bool);"));
        assert!(bridge.contains("float testFloat(float);"));
        assert!(bridge.contains("long long testLong(long long);"));
        assert!(bridge.contains("jboolean"));
        assert!(bridge.contains("jfloat"));
        assert!(bridge.contains("jlong"));
    }

    #[test]
    fn test_jni_name_generation() {
        assert_eq!(
            generate_jni_name("add", "com.example.ffi"),
            "Java_com_example_ffi_Math_add"
        );
        assert_eq!(
            generate_jni_name("multiply", "org.test"),
            "Java_org_test_Math_multiply"
        );
    }

    #[test]
    fn test_auto_generated_comment() {
        let functions = vec![CppFfiFunction {
            name: "test".to_string(),
            params: vec![],
            return_type: CppType::Void,
            source_file: PathBuf::from("test.cpp"),
        }];

        let bridge = generate_jni_bridge(&functions, "com.test", &["test.cpp".to_string()]);

        assert!(bridge.contains("Auto-generated by Whitehall FFI"));
        assert!(bridge.contains("DO NOT EDIT MANUALLY"));
    }

    #[test]
    fn test_string_parameter_conversion() {
        let func = CppFfiFunction {
            name: "greet".to_string(),
            params: vec![
                ("name".to_string(), CppType::String),
            ],
            return_type: CppType::String,
            source_file: PathBuf::from("string.cpp"),
        };

        let functions = vec![func];
        let bridge = generate_jni_bridge(&functions, "com.example", &["string.cpp".to_string()]);

        println!("{}", bridge);

        // Check forward declaration
        assert!(bridge.contains("std::string greet(const std::string&);"));

        // Check JNI function signature
        assert!(bridge.contains("jstring JNICALL"));
        assert!(bridge.contains("jstring name"));

        // Check string conversions
        assert!(bridge.contains("GetStringUTFChars"));
        assert!(bridge.contains("ReleaseStringUTFChars"));
        assert!(bridge.contains("NewStringUTF"));
        assert!(bridge.contains("std::string cpp_name"));

        // Check call with converted parameter
        assert!(bridge.contains("greet(cpp_name)"));

        // Check result conversion
        assert!(bridge.contains("jstring j_result"));
    }

    #[test]
    fn test_mixed_string_and_primitives() {
        let func = CppFfiFunction {
            name: "formatNumber".to_string(),
            params: vec![
                ("format".to_string(), CppType::String),
                ("number".to_string(), CppType::Int),
            ],
            return_type: CppType::String,
            source_file: PathBuf::from("format.cpp"),
        };

        let functions = vec![func];
        let bridge = generate_jni_bridge(&functions, "com.test", &["format.cpp".to_string()]);

        // Check forward declaration includes both types
        assert!(bridge.contains("std::string formatNumber(const std::string&, int);"));

        // Check JNI signature
        assert!(bridge.contains("jstring format"));
        assert!(bridge.contains("jint number"));

        // Check string conversion for format but not number
        assert!(bridge.contains("cpp_format"));
        assert!(bridge.contains("formatNumber(cpp_format, number)"));
    }

    #[test]
    fn test_string_return_only() {
        let func = CppFfiFunction {
            name: "getMessage".to_string(),
            params: vec![],
            return_type: CppType::String,
            source_file: PathBuf::from("msg.cpp"),
        };

        let functions = vec![func];
        let bridge = generate_jni_bridge(&functions, "com.test", &["msg.cpp".to_string()]);

        assert!(bridge.contains("std::string getMessage();"));
        assert!(bridge.contains("jstring JNICALL"));
        assert!(bridge.contains("NewStringUTF(result.c_str())"));
    }
}
