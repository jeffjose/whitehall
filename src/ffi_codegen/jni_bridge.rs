use crate::ffi_parser::cpp::{CppFfiFunction, CppType};

/// Generate JNI bridge code for all FFI functions
pub fn generate_jni_bridge(
    functions: &[CppFfiFunction],
    package: &str,
    source_files: &[String],
) -> String {
    let mut output = String::new();

    // Header comment
    output.push_str("/*\n");
    output.push_str(" * Auto-generated by Whitehall FFI\n");
    output.push_str(" * DO NOT EDIT MANUALLY\n");
    output.push_str(" */\n\n");

    // Include JNI header
    output.push_str("#include <jni.h>\n\n");

    // Include user source files
    for source_file in source_files {
        output.push_str(&format!("// User code\n"));
        output.push_str(&format!("#include \"{}\"\n", source_file));
    }
    output.push_str("\n");

    // Generate forward declarations for user functions
    output.push_str("// Forward declarations of user functions\n");
    for function in functions {
        output.push_str(&generate_forward_declaration(function));
    }
    output.push_str("\n");

    // Generate JNI bridge functions
    for function in functions {
        output.push_str(&generate_jni_function(function, package));
        output.push_str("\n");
    }

    output
}

/// Generate forward declaration for a user function
fn generate_forward_declaration(function: &CppFfiFunction) -> String {
    let params = function
        .params
        .iter()
        .map(|(_, typ)| cpp_type_to_string(typ))
        .collect::<Vec<_>>()
        .join(", ");

    format!(
        "{} {}({});\n",
        cpp_type_to_string(&function.return_type),
        function.name,
        params
    )
}

/// Generate JNI function wrapper
fn generate_jni_function(function: &CppFfiFunction, package: &str) -> String {
    let mut output = String::new();

    // Generate JNI function name
    let jni_name = generate_jni_name(&function.name, package);
    let jni_return_type = function.return_type.to_jni_type();

    // Function signature
    output.push_str("extern \"C\" JNIEXPORT ");
    output.push_str(jni_return_type);
    output.push_str(" JNICALL\n");
    output.push_str(&jni_name);
    output.push_str("(\n");
    output.push_str("    JNIEnv* env,\n");
    output.push_str("    jobject thiz");

    // Add parameters
    for (param_name, param_type) in function.params.iter() {
        output.push_str(",\n");
        output.push_str(&format!(
            "    {} {}",
            param_type.to_jni_type(),
            param_name
        ));
    }

    output.push_str("\n) {\n");

    // Function body - for Phase 1 (primitives only), we can directly call the user function
    output.push_str("    // Call user function\n");

    if function.return_type == CppType::Void {
        output.push_str(&format!("    {}(", function.name));
    } else {
        output.push_str(&format!("    return {}(", function.name));
    }

    // Pass parameters
    let param_names: Vec<String> = function
        .params
        .iter()
        .map(|(name, _)| name.clone())
        .collect();
    output.push_str(&param_names.join(", "));
    output.push_str(");\n");

    output.push_str("}\n");

    output
}

/// Generate JNI function name from Kotlin package and function name
/// Format: Java_com_example_ffi_ClassName_methodName
fn generate_jni_name(function_name: &str, package: &str) -> String {
    // Replace dots with underscores and add class name
    let package_path = package.replace('.', "_");
    // For now, we'll use "Math" as the default class name
    // TODO: Make this configurable or derive from source file
    format!("Java_{}_Math_{}", package_path, function_name)
}

/// Convert CppType to C++ type string
fn cpp_type_to_string(typ: &CppType) -> &'static str {
    match typ {
        CppType::Void => "void",
        CppType::Int => "int",
        CppType::Long => "long long",
        CppType::Float => "float",
        CppType::Double => "double",
        CppType::Bool => "bool",
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_generate_simple_jni_function() {
        let func = CppFfiFunction {
            name: "add".to_string(),
            params: vec![
                ("a".to_string(), CppType::Int),
                ("b".to_string(), CppType::Int),
            ],
            return_type: CppType::Int,
            source_file: PathBuf::from("math.cpp"),
        };

        let functions = vec![func];
        let bridge = generate_jni_bridge(&functions, "com.example.ffi", &["math.cpp".to_string()]);

        println!("{}", bridge);

        assert!(bridge.contains("#include <jni.h>"));
        assert!(bridge.contains("#include \"math.cpp\""));
        assert!(bridge.contains("int add(int, int);"));
        assert!(bridge.contains("Java_com_example_ffi_Math_add"));
        assert!(bridge.contains("jint"));
        assert!(bridge.contains("return add(a, b);"));
    }

    #[test]
    fn test_generate_no_params_function() {
        let func = CppFfiFunction {
            name: "getRandom".to_string(),
            params: vec![],
            return_type: CppType::Int,
            source_file: PathBuf::from("random.cpp"),
        };

        let functions = vec![func];
        let bridge = generate_jni_bridge(&functions, "com.test", &["random.cpp".to_string()]);

        assert!(bridge.contains("int getRandom();"));
        assert!(bridge.contains("return getRandom();"));
    }

    #[test]
    fn test_generate_void_return() {
        let func = CppFfiFunction {
            name: "doSomething".to_string(),
            params: vec![("x".to_string(), CppType::Int)],
            return_type: CppType::Void,
            source_file: PathBuf::from("test.cpp"),
        };

        let functions = vec![func];
        let bridge = generate_jni_bridge(&functions, "com.test", &["test.cpp".to_string()]);

        assert!(bridge.contains("void doSomething(int);"));
        assert!(bridge.contains("void JNICALL"));
        assert!(bridge.contains("doSomething(x);"));
        assert!(!bridge.contains("return doSomething"));
    }

    #[test]
    fn test_multiple_functions() {
        let functions = vec![
            CppFfiFunction {
                name: "add".to_string(),
                params: vec![
                    ("a".to_string(), CppType::Int),
                    ("b".to_string(), CppType::Int),
                ],
                return_type: CppType::Int,
                source_file: PathBuf::from("math.cpp"),
            },
            CppFfiFunction {
                name: "multiply".to_string(),
                params: vec![
                    ("x".to_string(), CppType::Double),
                    ("y".to_string(), CppType::Double),
                ],
                return_type: CppType::Double,
                source_file: PathBuf::from("math.cpp"),
            },
        ];

        let bridge = generate_jni_bridge(&functions, "com.example", &["math.cpp".to_string()]);

        assert!(bridge.contains("int add(int, int);"));
        assert!(bridge.contains("double multiply(double, double);"));
        assert!(bridge.contains("Java_com_example_Math_add"));
        assert!(bridge.contains("Java_com_example_Math_multiply"));
    }

    #[test]
    fn test_all_types() {
        let functions = vec![
            CppFfiFunction {
                name: "testBool".to_string(),
                params: vec![("b".to_string(), CppType::Bool)],
                return_type: CppType::Bool,
                source_file: PathBuf::from("test.cpp"),
            },
            CppFfiFunction {
                name: "testFloat".to_string(),
                params: vec![("f".to_string(), CppType::Float)],
                return_type: CppType::Float,
                source_file: PathBuf::from("test.cpp"),
            },
            CppFfiFunction {
                name: "testLong".to_string(),
                params: vec![("l".to_string(), CppType::Long)],
                return_type: CppType::Long,
                source_file: PathBuf::from("test.cpp"),
            },
        ];

        let bridge = generate_jni_bridge(&functions, "com.test", &["test.cpp".to_string()]);

        assert!(bridge.contains("bool testBool(bool);"));
        assert!(bridge.contains("float testFloat(float);"));
        assert!(bridge.contains("long long testLong(long long);"));
        assert!(bridge.contains("jboolean"));
        assert!(bridge.contains("jfloat"));
        assert!(bridge.contains("jlong"));
    }

    #[test]
    fn test_jni_name_generation() {
        assert_eq!(
            generate_jni_name("add", "com.example.ffi"),
            "Java_com_example_ffi_Math_add"
        );
        assert_eq!(
            generate_jni_name("multiply", "org.test"),
            "Java_org_test_Math_multiply"
        );
    }

    #[test]
    fn test_auto_generated_comment() {
        let functions = vec![CppFfiFunction {
            name: "test".to_string(),
            params: vec![],
            return_type: CppType::Void,
            source_file: PathBuf::from("test.cpp"),
        }];

        let bridge = generate_jni_bridge(&functions, "com.test", &["test.cpp".to_string()]);

        assert!(bridge.contains("Auto-generated by Whitehall FFI"));
        assert!(bridge.contains("DO NOT EDIT MANUALLY"));
    }
}
