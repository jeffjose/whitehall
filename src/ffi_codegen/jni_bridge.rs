use crate::ffi_parser::cpp::{CppFfiFunction, CppType};

/// Generate JNI bridge code for all FFI functions
pub fn generate_jni_bridge(
    functions: &[CppFfiFunction],
    package: &str,
    _source_files: &[String],
) -> String {
    let mut output = String::new();

    // Header comment
    output.push_str("/*\n");
    output.push_str(" * Auto-generated by Whitehall FFI\n");
    output.push_str(" * DO NOT EDIT MANUALLY\n");
    output.push_str(" */\n\n");

    // Include JNI header
    output.push_str("#include <jni.h>\n");
    output.push_str("#include <exception>\n");
    output.push_str("#include <stdexcept>\n\n");

    // Note: Source files are compiled together by CMake, no need to #include them
    // Generate forward declarations for user functions
    output.push_str("// Forward declarations of user functions\n");
    for function in functions {
        output.push_str(&generate_forward_declaration(function));
    }
    output.push_str("\n");

    // Generate JNI bridge functions
    for function in functions {
        output.push_str(&generate_jni_function(function, package));
        output.push_str("\n");
    }

    output
}

/// Check if a type is an array type
fn is_array_type(typ: &CppType) -> bool {
    matches!(typ, CppType::IntArray | CppType::LongArray | CppType::FloatArray | CppType::DoubleArray | CppType::BoolArray | CppType::StringArray)
}

/// Generate forward declaration for a user function
fn generate_forward_declaration(function: &CppFfiFunction) -> String {
    let params = function
        .params
        .iter()
        .map(|(_, typ)| {
            // For String and Array parameters, use const reference
            if *typ == CppType::String || is_array_type(typ) {
                format!("const {}&", typ.to_cpp_type())
            } else {
                typ.to_cpp_type().to_string()
            }
        })
        .collect::<Vec<_>>()
        .join(", ");

    format!(
        "{} {}({});\n",
        function.return_type.to_cpp_type(),
        function.name,
        params
    )
}

/// Generate JNI function wrapper
fn generate_jni_function(function: &CppFfiFunction, package: &str) -> String {
    let mut output = String::new();

    // Generate JNI function name
    let jni_name = generate_jni_name(&function.name, package);
    let jni_return_type = function.return_type.to_jni_type();

    // Function signature
    output.push_str("extern \"C\" JNIEXPORT ");
    output.push_str(jni_return_type);
    output.push_str(" JNICALL\n");
    output.push_str(&jni_name);
    output.push_str("(\n");
    output.push_str("    JNIEnv* env,\n");
    output.push_str("    jobject thiz");

    // Add parameters
    for (param_name, param_type) in function.params.iter() {
        output.push_str(",\n");
        output.push_str(&format!(
            "    {} {}",
            param_type.to_jni_type(),
            param_name
        ));
    }

    output.push_str("\n) {\n");

    // Phase 5: Wrap function call in try-catch for exception handling
    output.push_str("    try {\n");

    // Check if we have any string/array parameters or return types
    let has_strings_or_arrays = function.params.iter().any(|(_, t)| *t == CppType::String || is_array_type(t))
        || function.return_type == CppType::String || is_array_type(&function.return_type);

    if has_strings_or_arrays {
        // Phase 2/3: Handle string and array conversions
        output.push_str(&generate_complex_conversions(function));
    } else {
        // Phase 1: Direct call for primitives
        output.push_str("        // Call user function\n");

        if function.return_type == CppType::Void {
            output.push_str(&format!("        {}(", function.name));
        } else {
            output.push_str(&format!("        return {}(", function.name));
        }

        // Pass parameters
        let param_names: Vec<String> = function
            .params
            .iter()
            .map(|(name, _)| name.clone())
            .collect();
        output.push_str(&param_names.join(", "));
        output.push_str(");\n");
    }

    // Phase 5: Add exception handlers
    output.push_str("    } catch (const std::invalid_argument& e) {\n");
    output.push_str("        jclass exClass = env->FindClass(\"java/lang/IllegalArgumentException\");\n");
    output.push_str("        if (exClass != nullptr) {\n");
    output.push_str("            env->ThrowNew(exClass, e.what());\n");
    output.push_str("        }\n");
    output.push_str(&generate_default_return(&function.return_type));
    output.push_str("    } catch (const std::out_of_range& e) {\n");
    output.push_str("        jclass exClass = env->FindClass(\"java/lang/IndexOutOfBoundsException\");\n");
    output.push_str("        if (exClass != nullptr) {\n");
    output.push_str("            env->ThrowNew(exClass, e.what());\n");
    output.push_str("        }\n");
    output.push_str(&generate_default_return(&function.return_type));
    output.push_str("    } catch (const std::runtime_error& e) {\n");
    output.push_str("        jclass exClass = env->FindClass(\"java/lang/RuntimeException\");\n");
    output.push_str("        if (exClass != nullptr) {\n");
    output.push_str("            env->ThrowNew(exClass, e.what());\n");
    output.push_str("        }\n");
    output.push_str(&generate_default_return(&function.return_type));
    output.push_str("    } catch (const std::exception& e) {\n");
    output.push_str("        jclass exClass = env->FindClass(\"java/lang/RuntimeException\");\n");
    output.push_str("        if (exClass != nullptr) {\n");
    output.push_str("            env->ThrowNew(exClass, e.what());\n");
    output.push_str("        }\n");
    output.push_str(&generate_default_return(&function.return_type));
    output.push_str("    } catch (...) {\n");
    output.push_str("        jclass exClass = env->FindClass(\"java/lang/RuntimeException\");\n");
    output.push_str("        if (exClass != nullptr) {\n");
    output.push_str("            env->ThrowNew(exClass, \"Unknown C++ exception\");\n");
    output.push_str("        }\n");
    output.push_str(&generate_default_return(&function.return_type));
    output.push_str("    }\n");

    output.push_str("}\n");

    output
}

/// Generate default return value for exception cases
fn generate_default_return(return_type: &CppType) -> String {
    match return_type {
        CppType::Void => String::new(),
        CppType::Int | CppType::Long => "        return 0;\n".to_string(),
        CppType::Float | CppType::Double => "        return 0.0;\n".to_string(),
        CppType::Bool => "        return false;\n".to_string(),
        CppType::String | CppType::IntArray | CppType::LongArray |
        CppType::FloatArray | CppType::DoubleArray | CppType::BoolArray |
        CppType::StringArray => "        return nullptr;\n".to_string(),
    }
}

/// Generate complex type conversion code for JNI bridge (Phase 2/3: Strings and Arrays)
fn generate_complex_conversions(function: &CppFfiFunction) -> String {
    let mut output = String::new();

    // Convert string and array parameters
    for (param_name, param_type) in function.params.iter() {
        if *param_type == CppType::String {
            output.push_str(&generate_string_param_conversion(param_name, &function.return_type));
        } else if is_array_type(param_type) {
            output.push_str(&generate_array_param_conversion(param_name, param_type, &function.return_type));
        }
    }

    // Call the user function (Phase 5: indented for try-catch block)
    output.push_str("            // Call user function\n");
    let needs_result = function.return_type == CppType::String || is_array_type(&function.return_type);

    if needs_result {
        output.push_str(&format!("        auto result = {}(", function.name));
    } else if function.return_type == CppType::Void {
        output.push_str(&format!("        {}(", function.name));
    } else {
        output.push_str(&format!("        return {}(", function.name));
    }

    // Pass converted parameters
    let param_calls: Vec<String> = function
        .params
        .iter()
        .map(|(name, typ)| {
            if *typ == CppType::String || is_array_type(typ) {
                format!("cpp_{}", name)
            } else {
                name.clone()
            }
        })
        .collect();
    output.push_str(&param_calls.join(", "));
    output.push_str(");\n");

    // Convert return value if needed
    if function.return_type == CppType::String {
        output.push_str("\n        // Convert std::string to jstring\n");
        output.push_str("        jstring j_result = env->NewStringUTF(result.c_str());\n");
        output.push_str("        if (j_result == nullptr) {\n");
        output.push_str("            return nullptr;  // OutOfMemoryError\n");
        output.push_str("        }\n");
        output.push_str("        return j_result;\n");
    } else if is_array_type(&function.return_type) {
        output.push_str(&generate_array_return_conversion(&function.return_type));
    }

    output
}

/// Generate string parameter conversion
fn generate_string_param_conversion(param_name: &str, return_type: &CppType) -> String {
    let mut output = String::new();

    output.push_str(&format!(
        "    // Convert jstring to std::string\n"));
    output.push_str(&format!(
        "    if ({} == nullptr) {{\n", param_name));
    output.push_str("            // TODO: Handle null string - throw exception or return default\n");
    output.push_str(&format!(
        "        {} = env->NewStringUTF(\"\");\n", param_name));
    output.push_str("        }\n");

    output.push_str(&format!(
        "    const char* c_{} = env->GetStringUTFChars({}, nullptr);\n",
        param_name, param_name));
    output.push_str(&format!(
        "    if (c_{} == nullptr) {{\n", param_name));
    output.push_str("            return ");
    if *return_type == CppType::Void {
        output.push_str(";\n");
    } else if *return_type == CppType::String {
        output.push_str("env->NewStringUTF(\"\");\n");
    } else if is_array_type(return_type) {
        output.push_str("nullptr;\n");
    } else {
        output.push_str("0;  // OutOfMemoryError\n");
    }
    output.push_str("        }\n");

    output.push_str(&format!(
        "    std::string cpp_{}(c_{});\n",
        param_name, param_name));
    output.push_str(&format!(
        "    env->ReleaseStringUTFChars({}, c_{});\n\n",
        param_name, param_name));

    output
}

/// Generate array parameter conversion
fn generate_array_param_conversion(param_name: &str, param_type: &CppType, return_type: &CppType) -> String {
    let mut output = String::new();

    // Get the JNI array type and C++ element type
    let (jni_get, jni_release, _cpp_elem_type) = match param_type {
        CppType::IntArray => ("GetIntArrayElements", "ReleaseIntArrayElements", "int"),
        CppType::LongArray => ("GetLongArrayElements", "ReleaseLongArrayElements", "long long"),
        CppType::FloatArray => ("GetFloatArrayElements", "ReleaseFloatArrayElements", "float"),
        CppType::DoubleArray => ("GetDoubleArrayElements", "ReleaseDoubleArrayElements", "double"),
        CppType::BoolArray => ("GetBooleanArrayElements", "ReleaseBooleanArrayElements", "bool"),
        CppType::StringArray => {
            // String arrays are more complex - handle separately
            return generate_string_array_param_conversion(param_name, return_type);
        }
        _ => unreachable!(),
    };

    output.push_str(&format!("        // Convert {} to {}\n", param_type.to_jni_type(), param_type.to_cpp_type()));
    output.push_str(&format!("        if ({} == nullptr) {{\n", param_name));
    output.push_str("            return ");
    if *return_type == CppType::Void {
        output.push_str(";\n");
    } else if is_array_type(return_type) || *return_type == CppType::String {
        output.push_str("nullptr;\n");
    } else {
        output.push_str("0;\n");
    }
    output.push_str("        }\n");

    output.push_str(&format!("        jsize {}_len = env->GetArrayLength({});\n", param_name, param_name));
    output.push_str(&format!("        auto* {}_elems = env->{}({}, nullptr);\n",
        param_name, jni_get, param_name));
    output.push_str(&format!("        if ({}_elems == nullptr) {{\n", param_name));
    output.push_str("            return ");
    if *return_type == CppType::Void {
        output.push_str(";\n");
    } else if is_array_type(return_type) || *return_type == CppType::String {
        output.push_str("nullptr;\n");
    } else {
        output.push_str("0;\n");
    }
    output.push_str("        }\n");

    output.push_str(&format!("        {} cpp_{}({}_elems, {}_elems + {}_len);\n",
        param_type.to_cpp_type(), param_name, param_name, param_name, param_name));
    output.push_str(&format!("        env->{}({}, {}_elems, JNI_ABORT);  // Don't copy back\n\n",
        jni_release, param_name, param_name));

    output
}

/// Generate string array parameter conversion
fn generate_string_array_param_conversion(param_name: &str, return_type: &CppType) -> String {
    let mut output = String::new();

    output.push_str(&format!("        // Convert jobjectArray to std::vector<std::string>\n"));
    output.push_str(&format!("        if ({} == nullptr) {{\n", param_name));
    output.push_str("            return ");
    if *return_type == CppType::Void {
        output.push_str(";\n");
    } else {
        output.push_str("nullptr;\n");
    }
    output.push_str("        }\n");

    output.push_str(&format!("        jsize {}_len = env->GetArrayLength({});\n", param_name, param_name));
    output.push_str(&format!("        std::vector<std::string> cpp_{};\n", param_name));
    output.push_str(&format!("        cpp_{}.reserve({}_len);\n", param_name, param_name));
    output.push_str(&format!("        for (jsize i = 0; i < {}_len; ++i) {{\n", param_name));
    output.push_str(&format!("            jstring j_str = (jstring)env->GetObjectArrayElement({}, i);\n", param_name));
    output.push_str("            if (j_str != nullptr) {\n");
    output.push_str("                const char* c_str = env->GetStringUTFChars(j_str, nullptr);\n");
    output.push_str("                if (c_str != nullptr) {\n");
    output.push_str(&format!("                    cpp_{}.push_back(c_str);\n", param_name));
    output.push_str("                    env->ReleaseStringUTFChars(j_str, c_str);\n");
    output.push_str("                }\n");
    output.push_str("                env->DeleteLocalRef(j_str);\n");
    output.push_str("            }\n");
    output.push_str("        }\n\n");

    output
}

/// Generate array return value conversion
fn generate_array_return_conversion(return_type: &CppType) -> String {
    let mut output = String::new();

    if *return_type == CppType::StringArray {
        return generate_string_array_return_conversion();
    }

    let (jni_array_type, jni_new_array, jni_set_region) = match return_type {
        CppType::IntArray => ("jintArray", "NewIntArray", "SetIntArrayRegion"),
        CppType::LongArray => ("jlongArray", "NewLongArray", "SetLongArrayRegion"),
        CppType::FloatArray => ("jfloatArray", "NewFloatArray", "SetFloatArrayRegion"),
        CppType::DoubleArray => ("jdoubleArray", "NewDoubleArray", "SetDoubleArrayRegion"),
        CppType::BoolArray => ("jbooleanArray", "NewBooleanArray", "SetBooleanArrayRegion"),
        _ => unreachable!(),
    };

    output.push_str(&format!("\n    // Convert {} to {}\n", return_type.to_cpp_type(), return_type.to_jni_type()));
    output.push_str(&format!("    {} j_result = env->{}(result.size());\n", jni_array_type, jni_new_array));
    output.push_str("    if (j_result == nullptr) {\n");
    output.push_str("        return nullptr;  // OutOfMemoryError\n");
    output.push_str("    }\n");
    output.push_str(&format!("    env->{}(j_result, 0, result.size(), result.data());\n", jni_set_region));
    output.push_str("    return j_result;\n");

    output
}

/// Generate string array return value conversion
fn generate_string_array_return_conversion() -> String {
    let mut output = String::new();

    output.push_str("\n    // Convert std::vector<std::string> to jobjectArray\n");
    output.push_str("    jclass string_class = env->FindClass(\"java/lang/String\");\n");
    output.push_str("    jobjectArray j_result = env->NewObjectArray(result.size(), string_class, nullptr);\n");
    output.push_str("    if (j_result == nullptr) {\n");
    output.push_str("        return nullptr;  // OutOfMemoryError\n");
    output.push_str("    }\n");
    output.push_str("    for (size_t i = 0; i < result.size(); ++i) {\n");
    output.push_str("        jstring j_str = env->NewStringUTF(result[i].c_str());\n");
    output.push_str("        if (j_str != nullptr) {\n");
    output.push_str("            env->SetObjectArrayElement(j_result, i, j_str);\n");
    output.push_str("            env->DeleteLocalRef(j_str);\n");
    output.push_str("        }\n");
    output.push_str("    }\n");
    output.push_str("    return j_result;\n");

    output
}

/// Generate JNI function name from Kotlin package and function name
/// Format: Java_com_example_ffi_ClassName_methodName
fn generate_jni_name(function_name: &str, package: &str) -> String {
    // Replace dots with underscores and add class name
    let package_path = package.replace('.', "_");
    // For now, we'll use "Math" as the default class name
    // TODO: Make this configurable or derive from source file
    format!("Java_{}_Math_{}", package_path, function_name)
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_generate_simple_jni_function() {
        let func = CppFfiFunction {
            name: "add".to_string(),
            params: vec![
                ("a".to_string(), CppType::Int),
                ("b".to_string(), CppType::Int),
            ],
            return_type: CppType::Int,
            source_file: PathBuf::from("math.cpp"),
        };

        let functions = vec![func];
        let bridge = generate_jni_bridge(&functions, "com.example.ffi", &["math.cpp".to_string()]);

        println!("{}", bridge);

        assert!(bridge.contains("#include <jni.h>"));
        assert!(bridge.contains("#include \"math.cpp\""));
        assert!(bridge.contains("int add(int, int);"));
        assert!(bridge.contains("Java_com_example_ffi_Math_add"));
        assert!(bridge.contains("jint"));
        assert!(bridge.contains("return add(a, b);"));
    }

    #[test]
    fn test_generate_no_params_function() {
        let func = CppFfiFunction {
            name: "getRandom".to_string(),
            params: vec![],
            return_type: CppType::Int,
            source_file: PathBuf::from("random.cpp"),
        };

        let functions = vec![func];
        let bridge = generate_jni_bridge(&functions, "com.test", &["random.cpp".to_string()]);

        assert!(bridge.contains("int getRandom();"));
        assert!(bridge.contains("return getRandom();"));
    }

    #[test]
    fn test_generate_void_return() {
        let func = CppFfiFunction {
            name: "doSomething".to_string(),
            params: vec![("x".to_string(), CppType::Int)],
            return_type: CppType::Void,
            source_file: PathBuf::from("test.cpp"),
        };

        let functions = vec![func];
        let bridge = generate_jni_bridge(&functions, "com.test", &["test.cpp".to_string()]);

        assert!(bridge.contains("void doSomething(int);"));
        assert!(bridge.contains("void JNICALL"));
        assert!(bridge.contains("doSomething(x);"));
        assert!(!bridge.contains("return doSomething"));
    }

    #[test]
    fn test_multiple_functions() {
        let functions = vec![
            CppFfiFunction {
                name: "add".to_string(),
                params: vec![
                    ("a".to_string(), CppType::Int),
                    ("b".to_string(), CppType::Int),
                ],
                return_type: CppType::Int,
                source_file: PathBuf::from("math.cpp"),
            },
            CppFfiFunction {
                name: "multiply".to_string(),
                params: vec![
                    ("x".to_string(), CppType::Double),
                    ("y".to_string(), CppType::Double),
                ],
                return_type: CppType::Double,
                source_file: PathBuf::from("math.cpp"),
            },
        ];

        let bridge = generate_jni_bridge(&functions, "com.example", &["math.cpp".to_string()]);

        assert!(bridge.contains("int add(int, int);"));
        assert!(bridge.contains("double multiply(double, double);"));
        assert!(bridge.contains("Java_com_example_Math_add"));
        assert!(bridge.contains("Java_com_example_Math_multiply"));
    }

    #[test]
    fn test_all_types() {
        let functions = vec![
            CppFfiFunction {
                name: "testBool".to_string(),
                params: vec![("b".to_string(), CppType::Bool)],
                return_type: CppType::Bool,
                source_file: PathBuf::from("test.cpp"),
            },
            CppFfiFunction {
                name: "testFloat".to_string(),
                params: vec![("f".to_string(), CppType::Float)],
                return_type: CppType::Float,
                source_file: PathBuf::from("test.cpp"),
            },
            CppFfiFunction {
                name: "testLong".to_string(),
                params: vec![("l".to_string(), CppType::Long)],
                return_type: CppType::Long,
                source_file: PathBuf::from("test.cpp"),
            },
        ];

        let bridge = generate_jni_bridge(&functions, "com.test", &["test.cpp".to_string()]);

        assert!(bridge.contains("bool testBool(bool);"));
        assert!(bridge.contains("float testFloat(float);"));
        assert!(bridge.contains("long long testLong(long long);"));
        assert!(bridge.contains("jboolean"));
        assert!(bridge.contains("jfloat"));
        assert!(bridge.contains("jlong"));
    }

    #[test]
    fn test_jni_name_generation() {
        assert_eq!(
            generate_jni_name("add", "com.example.ffi"),
            "Java_com_example_ffi_Math_add"
        );
        assert_eq!(
            generate_jni_name("multiply", "org.test"),
            "Java_org_test_Math_multiply"
        );
    }

    #[test]
    fn test_auto_generated_comment() {
        let functions = vec![CppFfiFunction {
            name: "test".to_string(),
            params: vec![],
            return_type: CppType::Void,
            source_file: PathBuf::from("test.cpp"),
        }];

        let bridge = generate_jni_bridge(&functions, "com.test", &["test.cpp".to_string()]);

        assert!(bridge.contains("Auto-generated by Whitehall FFI"));
        assert!(bridge.contains("DO NOT EDIT MANUALLY"));
    }

    #[test]
    fn test_string_parameter_conversion() {
        let func = CppFfiFunction {
            name: "greet".to_string(),
            params: vec![
                ("name".to_string(), CppType::String),
            ],
            return_type: CppType::String,
            source_file: PathBuf::from("string.cpp"),
        };

        let functions = vec![func];
        let bridge = generate_jni_bridge(&functions, "com.example", &["string.cpp".to_string()]);

        println!("{}", bridge);

        // Check forward declaration
        assert!(bridge.contains("std::string greet(const std::string&);"));

        // Check JNI function signature
        assert!(bridge.contains("jstring JNICALL"));
        assert!(bridge.contains("jstring name"));

        // Check string conversions
        assert!(bridge.contains("GetStringUTFChars"));
        assert!(bridge.contains("ReleaseStringUTFChars"));
        assert!(bridge.contains("NewStringUTF"));
        assert!(bridge.contains("std::string cpp_name"));

        // Check call with converted parameter
        assert!(bridge.contains("greet(cpp_name)"));

        // Check result conversion
        assert!(bridge.contains("jstring j_result"));
    }

    #[test]
    fn test_mixed_string_and_primitives() {
        let func = CppFfiFunction {
            name: "formatNumber".to_string(),
            params: vec![
                ("format".to_string(), CppType::String),
                ("number".to_string(), CppType::Int),
            ],
            return_type: CppType::String,
            source_file: PathBuf::from("format.cpp"),
        };

        let functions = vec![func];
        let bridge = generate_jni_bridge(&functions, "com.test", &["format.cpp".to_string()]);

        // Check forward declaration includes both types
        assert!(bridge.contains("std::string formatNumber(const std::string&, int);"));

        // Check JNI signature
        assert!(bridge.contains("jstring format"));
        assert!(bridge.contains("jint number"));

        // Check string conversion for format but not number
        assert!(bridge.contains("cpp_format"));
        assert!(bridge.contains("formatNumber(cpp_format, number)"));
    }

    #[test]
    fn test_string_return_only() {
        let func = CppFfiFunction {
            name: "getMessage".to_string(),
            params: vec![],
            return_type: CppType::String,
            source_file: PathBuf::from("msg.cpp"),
        };

        let functions = vec![func];
        let bridge = generate_jni_bridge(&functions, "com.test", &["msg.cpp".to_string()]);

        assert!(bridge.contains("std::string getMessage();"));
        assert!(bridge.contains("jstring JNICALL"));
        assert!(bridge.contains("NewStringUTF(result.c_str())"));
    }
}
