# Suspend Functions and Coroutine Scopes

**Status:** ✅ Phase 2 Complete - Implemented and Tested

---

## Overview

This document covers the complete design and implementation of suspend function and coroutine scope features in Whitehall. The implementation provides three levels of control for async operations:

1. **Level 1:** Auto-infer scope (future - requires var → ViewModel)
2. **Level 2:** Thread control with dispatchers (`io`, `cpu`, `main`) ✅ **IMPLEMENTED**
3. **Level 3:** Custom scopes (`$scope()`) ✅ **IMPLEMENTED**

---

## Design: Special Syntax Patterns

Whitehall uses two prefix patterns for clarity:

| Pattern | Meaning | Examples |
|---------|---------|----------|
| `@` prefix | **Declare** special behavior | `@prop val name`, `@store object Settings`, `@inject constructor()` |
| `$` prefix | **Access** compiler-provided values | `$screen.params.id`, `$route.profile`, `$scope()` |

**Rule:**
- `@` = "This IS something special" (declaration/annotation)
- `$` = "Get me something special" (reference/access)

---

## Level 1: Auto-Infer (Future Implementation)

**Design:** Auto-infer the appropriate scope from context (90% case).

```whitehall
var isLoading = false

suspend fun save() {
  isLoading = true
  api.save()
  isLoading = false
}

<Button onClick={save}>Save</Button>
```

**Auto-inference rules:**
- Component with `var` → Uses `viewModelScope.launch`
- Inside `onMount` → Already in `LaunchedEffect` scope
- Component without `var` → Uses `rememberCoroutineScope()`
- Singleton (`@store object`) → Keep as `suspend`, caller provides scope

**Status:** ⏳ Pending - Requires Phase 1.1 (var → ViewModel generation)

---

## Level 2: Thread Control (Dispatchers) ✅

**Status:** ✅ IMPLEMENTED

### The Three Dispatchers

| Dispatcher | Whitehall Syntax | When to Use | Kotlin Equivalent |
|------------|------------------|-------------|-------------------|
| **Main** | `main { }` | UI updates (auto default) | `Dispatchers.Main` |
| **IO** | `io { }` | Network, disk, database | `Dispatchers.IO` |
| **CPU** | `cpu { }` | Heavy computation | `Dispatchers.Default` |

### Examples

```whitehall
var data = []
var processedData = []

suspend fun loadData() {
  data = api.fetch()
}

suspend fun processData() {
  processedData = heavyComputation(data)
}

<!-- Explicit IO thread (network/disk operations) -->
<Button onClick={() => io { loadData() }}>Load Data</Button>

<!-- Explicit CPU thread (heavy computation) -->
<Button onClick={() => cpu { processData() }}>Process</Button>

<!-- Force main thread (rare, usually automatic) -->
<Button onClick={() => main { updateUI() }}>Update UI</Button>
```

### Generated Kotlin

```kotlin
@Composable
fun MyComponent() {
    var data by remember { mutableStateOf(emptyList()) }

    val dispatcherScope = rememberCoroutineScope()  // Auto-generated

    suspend fun loadData() { data = api.fetch() }

    Button(onClick = {
        dispatcherScope.launch(Dispatchers.IO) {
            loadData()
        }
    })

    Button(onClick = {
        dispatcherScope.launch(Dispatchers.Default) {
            processData()
        }
    })
}
```

### Implementation Details

**Parser (parser.rs:90-97):**
- Added `suspend` keyword detection at component level
- Supports suspend functions in top-level component declarations

**Code Generator (compose.rs:2251-2267):**
```rust
fn transform_dispatchers(&self, value: &str) -> String {
    let mut result = value.to_string();
    result = result.replace("io {", "dispatcherScope.launch(Dispatchers.IO) {");
    result = result.replace("cpu {", "dispatcherScope.launch(Dispatchers.Default) {");
    result = result.replace("main {", "dispatcherScope.launch(Dispatchers.Main) {");
    result
}
```

**Auto-Detection (compose.rs:139-147):**
- Detects dispatcher usage in markup via string pattern matching
- Auto-generates `val dispatcherScope = rememberCoroutineScope()` when needed

**Auto-Imports (compose.rs:643-652):**
- Automatically adds `kotlinx.coroutines.Dispatchers`
- Automatically adds `kotlinx.coroutines.launch`
- Automatically adds `androidx.compose.runtime.rememberCoroutineScope`

---

## Level 3: Custom Scopes ✅

**Status:** ✅ IMPLEMENTED

### Purpose
For independent lifecycle management (e.g., cancellable operations).

### Syntax

```whitehall
var isUploading = false

val uploadScope = $scope()  // Special compiler-provided scope function

suspend fun uploadLargeFile() {
  isUploading = true
  api.upload(largeFile)
  isUploading = false
}

fun cancelUpload() {
  uploadScope.cancel()
}

<Button onClick={() => uploadScope.launch { uploadLargeFile() }}>
  Upload File
</Button>

<Button onClick={cancelUpload} disabled={!isUploading}>
  Cancel Upload
</Button>
```

### Generated Kotlin

```kotlin
@Composable
fun MyScreen() {
    var isUploading by remember { mutableStateOf(false) }
    val uploadScope = rememberCoroutineScope()  // ← Generated by $scope()

    suspend fun uploadLargeFile() {
        isUploading = true
        api.upload(largeFile)
        isUploading = false
    }

    fun cancelUpload() {
        uploadScope.cancel()
    }

    Button(onClick = {
        uploadScope.launch {
            uploadLargeFile()
        }
    })

    Button(
        onClick = { cancelUpload() },
        enabled = !isUploading
    )
}
```

### Implementation Details

**Detection (compose.rs:368-372):**
```rust
// Check if this is a custom scope: $scope() → rememberCoroutineScope()
if transformed_value.trim() == "$scope()" {
    output.push_str(&format!("val {} = rememberCoroutineScope()\n", state.name));
    continue;
}
```

**Note:** `$scope()` uses the `$` prefix for special compiler-provided functions, consistent with `$screen` and `$route`.

---

## Complete Example: All Three Levels

```whitehall
var data = []
var isUploading = false

val uploadScope = $scope()

// Level 1: Auto (uses viewModelScope, main thread)
suspend fun saveSimple() {
  api.save(data)
}

// Level 2: Explicit IO thread
suspend fun loadData() {
  data = api.fetch()
}

// Level 2: Explicit CPU thread
suspend fun processData() {
  data = processLargeDataset(data)
}

// Level 3: Custom scope for cancellation
suspend fun uploadFile() {
  isUploading = true
  api.upload(largeFile)
  isUploading = false
}

fun cancelUpload() {
  uploadScope.cancel()
}

<!-- Level 1: Auto (simple) -->
<Button onClick={saveSimple}>Save</Button>

<!-- Level 2: Explicit IO thread -->
<Button onClick={() => io { loadData() }}>Load Data</Button>

<!-- Level 2: Explicit CPU thread -->
<Button onClick={() => cpu { processData() }}>Process</Button>

<!-- Level 3: Custom scope -->
<Button onClick={() => uploadScope.launch { uploadFile() }}>Upload</Button>
<Button onClick={cancelUpload}>Cancel</Button>
```

---

## Implementation Status

### ✅ Completed (Phase 2)

1. **Suspend Function Parsing** - Components can declare `suspend fun` at top level
   - Parser: `src/transpiler/parser.rs:90-97`
   - Suspend keyword preserved in generated code

2. **Dispatcher Syntax** - Thread control with `io { }`, `cpu { }`, `main { }`
   - Transformation: `src/transpiler/codegen/compose.rs:2251-2267`
   - Auto-detection: `src/transpiler/codegen/compose.rs:139-147`
   - Auto-generates `dispatcherScope` when needed

3. **Custom Scope Syntax** - `$scope()` transformation
   - Detection: `src/transpiler/codegen/compose.rs:368-372`
   - Transforms to `rememberCoroutineScope()`

4. **Auto-Import Detection** - All coroutine imports automatically added
   - Dispatchers import: `compose.rs:643-652`
   - CoroutineScope import: `compose.rs:654-663`
   - Launch import: `compose.rs:632-641`

### ⏳ Pending (Phase 1.1 Required)

**Level 1 Auto-Infer:**
- Requires inline `var` → ViewModel generation
- Context-aware scope selection (viewModelScope vs dispatcherScope)
- Auto-wrap suspend functions in ViewModels

---

## Test Files

### DispatcherTest.wh
**Location:** `examples/counter-store/src/components/DispatcherTest.wh`

Tests all three dispatcher types:

```whitehall
var count: Int = 0

suspend fun loadData() {
  count++
}

suspend fun processData() {
  count = count * 2
}

suspend fun updateUI() {
  count = count + 10
}

<Column padding={16} spacing={12}>
  <Text fontSize={24}>Dispatcher Test: {count}</Text>

  <Button onClick={() => io { loadData() }}>
    IO: Load Data
  </Button>

  <Button onClick={() => cpu { processData() }}>
    CPU: Process Data
  </Button>

  <Button onClick={() => main { updateUI() }}>
    Main: Update UI
  </Button>
</Column>
```

**Generated:** `build/.../DispatcherTest.kt` with proper scope and imports

### CustomScopeTest.wh
**Location:** `examples/counter-store/src/components/CustomScopeTest.wh`

Tests custom scope creation and usage:

```whitehall
var uploadCount: Int = 0
var downloadCount: Int = 0

val uploadScope = $scope()
val downloadScope = $scope()

suspend fun uploadFile() {
  uploadCount++
}

suspend fun downloadFile() {
  downloadCount++
}

<Column padding={16} spacing={12}>
  <Text fontSize={24}>Custom Scope Test</Text>
  <Text>Uploads: {uploadCount}</Text>
  <Text>Downloads: {downloadCount}</Text>

  <Button onClick={() => uploadScope.launch { uploadFile() }}>
    Upload File
  </Button>

  <Button onClick={() => downloadScope.launch { downloadFile() }}>
    Download File
  </Button>
</Column>
```

---

## Key Implementation Files

| Component | File | Lines | Description |
|-----------|------|-------|-------------|
| Suspend parsing | `parser.rs` | 90-97 | Parse `suspend fun` at component level |
| Dispatcher transform | `compose.rs` | 2251-2267 | Transform io/cpu/main to Dispatchers |
| Dispatcher detection | `compose.rs` | 139-147 | Auto-detect dispatcher usage |
| Scope generation | `compose.rs` | 436-440 | Auto-generate dispatcherScope |
| $scope() detection | `compose.rs` | 368-372 | Transform $scope() calls |
| Import detection | `compose.rs` | 619-663 | Auto-add coroutine imports |

---

## Future Enhancements

### Phase 1.1 Integration
When inline `var` → ViewModel generation is implemented:

1. **Context-aware dispatcher scope:**
   - Components with `var` → Use `viewModelScope.launch`
   - Components without `var` → Use `dispatcherScope.launch`

2. **Auto-wrap suspend functions:**
   - ViewModel functions auto-wrap in `viewModelScope.launch`
   - As designed in Level 1

### Potential Improvements

1. **Error messages:**
   - Warn if using `io` for CPU-bound work
   - Warn if using `cpu` for I/O operations
   - Suggest correct dispatcher

2. **Advanced features:**
   - Support cancellation (`scope.cancel()`)
   - Support structured concurrency patterns
   - Dispatcher configuration

---

## Migration from Current Implementation

**Current (Phases 0-5):**
- `@store` annotation for screen-scoped state ✅
- Auto-detection at usage sites ✅
- Hilt integration ✅
- Auto-wrap suspend functions ✅

**Phase 2 Additions:**
- Dispatcher syntax (`io`/`cpu`/`main`) ✅
- Custom scope syntax (`$scope()`) ✅
- Auto-import detection ✅

**Breaking changes:** None - all new features

---

## Related Documentation

- [STORE.md](STORE.md) - State management and @store implementation
- [STATE-MANAGEMENT.md](STATE-MANAGEMENT.md) - Overall state management design

---

## Commit History

- `882b89e` - Complete Phase 2: Suspend functions and coroutine scopes
- Full implementation of dispatcher syntax and custom scopes
- Auto-import detection and scope generation
- Comprehensive test files and examples
